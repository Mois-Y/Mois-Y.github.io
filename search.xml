<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端面试常见问题2</title>
      <link href="/2020/09/15/qian-duan-mian-shi-chang-jian-wen-ti-2/"/>
      <url>/2020/09/15/qian-duan-mian-shi-chang-jian-wen-ti-2/</url>
      
        <content type="html"><![CDATA[<style>    .context{        font-size:13pt;    }    .m-context{        font-size: 12pt;    }</style><h2>1、盒子模型</h2><div class="context">组成部分：<br/><li>Margin(外边距) - 清除边框外的区域，外边距是透明的。</li><li>Border(边框) - 围绕在内边距和内容外的边框。</li><li>Padding(内边距) - 清除内容周围的区域，内边距是透明的。</li><li>Content(内容) - 盒子的内容，显示文本和图像。</li>标准盒模型：box-sizing:content-box（默认）<br/>怪异盒模型：box-sizing:border-box</div><h3>1、标准盒模型与怪异（IE）盒模型区别：</h3><div class="m-context">IE模型元素宽度：width=content+padding+border，<br/>标准模型元素宽度：width=content</div><h3>2、BFC(块级格式化上下文)</h3><div class="m-context">它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。<br/><b>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</b></div><h4>2.1 触发BFC</h4><a>https://zhuanlan.zhihu.com/p/25321647</a><div class="m-context"><li>body根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></div><h4>2.2 BFC特性及应用</h4><div class="m-context"><li>1 同一个BFC下外边距会发生折叠</li>如两个div元素margin都为100px时，第二个div的上边距发生重叠，盒子间距离只有100px，而不是200px,若要避免，可以将其放在不同的BFC容器中。<li>2 BFC 可以包含浮动的元素（清除浮动）</li>浮动的元素会脱离普通文档流，因此使触发元素的BFC（如：overflow:hidden），容器将会包裹着浮动元素<li>3 BFC可以阻止元素被浮动元素覆盖（overflow: hidden）</li></div><h2>2、this实例、改变this指向</h2><a>https://www.cnblogs.com/pssp/p/5216085.html</a><div class="context">1、<b>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象</b>，如果this没有被上一级对象所调用，this指向window；如果被上一级对象所调用，this指向上一级对象。<br/>2、如果一个函数中有this，这个函数中包含多个对象，尽管这个函数是被最外层的对象所调用，this指向的也只是它上一级的对象。<br/>3、在<b>严格模式</b>中的默认的this不再是window，而是undefined<br/>4、<b>当this碰到return时：</b>如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。<br/>5、虽然null也是对象，但是在这里this还是指向那个函数的实例，因为null比较特殊。<br/></div><h3>2.1 改变this指向的方法</h3><a>https://www.cnblogs.com/pssp/p/5215621.html</a><h4>1、call()</h4><div class="m-context">通过在call方法，给第一个参数添加要把b添加到哪个环境中，简单来说，this就会指向那个对象。call方法除了第一个参数以外还可以添加多个参数<br/><pre><code>var a &#x3D; {    user:&quot;追梦子&quot;,    fn:function(){        console.log(this.user); &#x2F;&#x2F;追梦子    },    &#x2F;&#x2F; fn:function(e,ee){    &#x2F;&#x2F;    console.log(this.user); &#x2F;&#x2F;追梦子    &#x2F;&#x2F;    console.log(e+ee); &#x2F;&#x2F;3    &#x2F;&#x2F; }}var b &#x3D; a.fn;b.call(a);&#x2F;&#x2F; b.call(a,1,2)</code></pre></div><h4>2、apply()</h4><div class="m-context">apply方法和call方法有些相似，它也可以改变this的指向<br/><pre><code>var a &#x3D; {    user:&quot;追梦子&quot;,    fn:function(e,ee){        console.log(this.user); &#x2F;&#x2F;追梦子        console.log(e+ee); &#x2F;&#x2F;11    }}var b &#x3D; a.fn;b.apply(a,[10,1]);&#x2F;&#x2F; var b &#x3D; a.fn;&#x2F;&#x2F; var arr &#x3D; [500,20];&#x2F;&#x2F; b.apply(a,arr);</code></pre></div><b>ps:如果call和apply的第一个参数写的是null，那么this指向的是window对象</b><h4>3、bind()</h4><div class="m-context"><b>bind方法返回的是一个修改过后的函数。</b><pre><code>var a &#x3D; {    user:&quot;追梦子&quot;,    fn:function(){        console.log(this.user); &#x2F;&#x2F;追梦子    }}var b &#x3D; a.fn;var c &#x3D; b.bind(a);c();</code></pre><b>bind也可以有多个参数，并可以在执行的时候再次添加，但是要注意的是，参数是按照形参的顺序进行的。</b><pre><code>var a &#x3D; {    user:&quot;追梦子&quot;,    fn:function(e,d,f){        console.log(this.user); &#x2F;&#x2F;追梦子        console.log(e,d,f); &#x2F;&#x2F;10 1 2    }}var b &#x3D; a.fn;var c &#x3D; b.bind(a,10);c(1,2);</code></pre></div><h4>call、apply与bind的区别：</h4><b>1、call和apply都是改变上下文中的this并立即执行这个函数</b><br/><b>2、bind方法可以让对应的函数想什么时候调就什么时候调用，并且可以将参数在执行的时候添加</b><h2>3、语义化作用及标签</h2><h3>3.1 引入语义化标签的优点：</h3><div class="m-context"><li>比div标签有更加丰富的含义，方便开发与维护</li><li>搜索引擎能更方便的识别页面的每个部分</li><li>方便其他设备解析（如移动设备、盲人阅读器等）</li></div><h3>3.2 html5新增语义化区块标签</h3><div class="m-context"><li>article: 表示包含于一个文档、页面、应用程序或网站中的一段独立的内容，可以被独立的发布或者重新使用文章标记标签。</li><li>section: 是一个主题性的内容分组，通常用于对页面进行分块或者对文章等进行分段</li><li>nav: 表示页面的导航，可以通过导航连接到网站的其他页面，或者当前页面的其它部分。</li><li>aside: 所包含的内容不是页面的主要内容、具有独立性，是对页面的补充。一般使用在页面、文章的侧边栏、广告、友情链接等区域。</li><li>header: 通常被放置在页面或者页面中某个区块元素的顶部，包含整个页面或者区块的标题、简介等信息，起到引导与导航的作用。</li><li>footer: 一般被放置在页面或者页面中某个区块的底部，包含版权信息、联系方式等信息。</li><li>mark: 高亮标记一段文字</li><li>time: 为了将现在的常用的日期和时间语句用规范的、利于机器识别的格式进行表述，time元素提供了一个可选的时间和时区组件。</li><a>https://www.jianshu.com/p/c41b88217834</a></div><h2>4、正则表达式</h2><a>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a><h2>5、异步代码</h2><div class="context">因为各种原因（如阻塞），很多网页API特性使用异步代码，特别是从外部的设备上获取资源，譬如，从网络获取文件，访问数据库，从网络摄像头获得视频流，或者向VR头罩广播图像。<br/>不等任务执行完、直接执行下一个任务。<br/>在JavaScript代码中，经常会遇到两种异步编程风格：老派callbacks，新派promise。</div><h3>5.1 异步callbacks</h3><div class="m-context">异步callbacks 其实就是函数，只不过是作为参数传递给那些在后台执行的其他函数. 当那些后台运行的代码结束，就调用callbacks函数，通知你工作已经完成，或者其他有趣的事情发生了。<br/>回调经常用于获取异步任务的结果<pre><code>function taskAsync &#x3D; function(callback){  var result &#x3D; setTimeout(function(){    callback(&#39;异步任务的结果&#39;)  }, 3000)  return result}taskAsync(function callback(result){  console.log(result) &#x2F;&#x2F; 三秒钟后，这个 callback 函数会被执行})otherTask()              &#x2F;&#x2F; 立即执行其他任务，不等异步任务结束</code></pre></div><h3>5.2 异步promise</h3><div class="m-context">Promise的几种状态：<li>pending: 初始状态</li><li>fulfilled: 意味着操作成功完成</li><li>rejected: 意味着操作失败</li><b>Promise 对象的 then 方法绑定的处理方法（handlers）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。</b><pre><code>let myFirstPromise &#x3D; new Promise(function(resolve, reject){    &#x2F;&#x2F;当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...)    &#x2F;&#x2F;在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法.    setTimeout(function(){        resolve(&quot;成功!&quot;); &#x2F;&#x2F;代码正常执行！    }, 250);});myFirstPromise.then(function(successMessage){    &#x2F;&#x2F;successMessage的值是上面调用resolve(...)方法传入的值.    &#x2F;&#x2F;successMessage参数不一定非要是字符串类型，这里只是举个例子    console.log(&quot;Yay! &quot; + successMessage);});</code></pre></div><h2>6、http请求方法</h2><div class="context">HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。<br/>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。<li>GET: 请求指定的页面信息，并返回实体主体。</li><li>HEAD: 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</li><li>POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。</li><li>PUT: 从客户端向服务器传送的数据取代指定的文档的内容。</li><li>DELETE: 请求服务器删除指定的页面。</li><li>CONNECT: HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li><li>OPTIONS: 允许客户端查看服务器的性能。</li><li>TRACE: 回显服务器收到的请求，主要用于测试或诊断。</li><li>PATCH: 是对 PUT 方法的补充，用来对已知资源进行局部更新</li></div><h2>7、变量提升与函数提升</h2>链接：<a>https://juejin.im/post/6844903922457395208</a><h3>7.1 变量提升</h3><div class="context"><b>变量提升仅提升声明，不提升初始化</b><pre><code>console.log(a);var a &#x3D; 8;&#x2F;&#x2F; 变量提升后等价于下面代码var a;console.log(a) &#x2F;&#x2F; undefineda &#x3D; 8;</code></pre><pre><code>var a &#x3D; 8;function fn() {    console.log(a);    var a &#x3D; 9;    console.log(a);}&#x2F;&#x2F; 变量提升后等价于下面代码var a &#x3D; 8;function fn() {    var a;    console.log(a);    a &#x3D; 9;    console.log(a);}</code></pre></div><h3>7.2 函数提升</h3><div class="context"><b>js中创建函数有两种方式：函数声明式和函数字面量式。只有函数声明才存在函数提升。</b><br/>字面量式：var fun=function test(){};<pre><code>console.log(f1);  console.log(f2);  function f1() {}var f2 &#x3D; function() {}&#x2F;&#x2F; 函数提升后等价于下面代码function f1() {}var fn;console.log(f1); &#x2F;&#x2F; function f1() {}   console.log(f2); &#x2F;&#x2F; undefined  f2 &#x3D; function() {}</code></pre></div><h3>7.3 变量提升 VS 函数提升</h3><div class="m-context"><b>在js代码执行前，会执行词法分析。函数运行瞬间会生成活动对象AO</b><br/><li>1 分析形参</li>如果函数有形参，则给当前活动对象增加属性，赋值为undefined。<li>2 分析变量</li>1 如果AO上还没有 XXX 属性，则给当前活动对象增加属性，赋值为undefined.<br/>2 如果AO上有 XXX 属性，则不做任何影响。<li>3 分析函数</li>1 把函数赋值给 AO.func 属性<br/>2 如果此前 func 属性已存在，则覆盖。<b>(证明函数的优先级比较高)</b><pre><code>var a&#x3D;2;function a() {    console.log(3);}console.log(typeof a);&#x2F;&#x2F; 变量提升和函数提升后，代码变为function a() {    console.log(3);}a&#x3D;2;console.log(typeof a); &#x2F;&#x2F; number&#x2F;&#x2F; 此处变量a把函数a覆盖</code></pre></div><h2>8、brower对象</h2><div class="context">包含：Window对象、History对象、Location对象、Navigator对象、Screen对象</div><h3>Window对象</h3><div class="m-context"><li>弹出警告框、确认框</li><li>打开一个或多个新窗口、关闭新窗口等</li><li>打印当前页面</li><li>指定窗口大小</li></div><h3>History对象</h3><div class="m-context"><li>返回一个url的历史清单</li><li>创建前进、后退按钮</li><li>从url的历史清单转到指定的url</li></div><h3>Location对象</h3><div class="m-context"><li>返回主机名和当前url端口</li><li>返回当前页面的url</li><li>返回当前url路径名、协议部分</li><li>加载、重新载入、替代文档</li><li>跳出框架</li></div><h3>Navigator对象</h3><div class="m-context"><li>访问者的浏览器详细</li></div><h3>Screen对象</h3><div class="m-context"><li>访问者屏幕的详细</li></div><h2>9、boolean为true</h2><div class="context">如果省略或值0，-0，null，false，NaN，undefined，或空字符串（""），该对象具有的初始值false。<br/>所有其他值，包括任何对象，空数组（[]）或字符串"false"，都会创建一个初始值为的对象true。<br/><b>创建值为 false 的 Boolean 对象</b><br/>var bNoParam = new Boolean();<br/>var bZero = new Boolean(0);<br/>var bNull = new Boolean(null);<br/>var bEmptyString = new Boolean('');<br/>var bfalse = new Boolean(false);<br/><b>创建值为 true 的  Boolean 对象</b><br/>var btrue = new Boolean(true);<br/>var btrueString = new Boolean('true');<br/>var bfalseString = new Boolean('false');<br/>var bSuLin = new Boolean('Su Lin');<br/>var bArrayProto = new Boolean([]);<br/>var bObjProto = new Boolean({});<br/></div><h2>10、暂时死区</h2><h2>11、获取元素方法</h2><h2>12、异步模式方法</h2><h2>13、canvas与svg区别</h2><h2>14、ES5 ES6区别</h2><h2>15、hasOwnProperty、isPrototypeof区别</h2><h2>16、concat、append、appendTo、pop区别</h2><h2>17、JS内置对象</h2><h2>18、严格模式，严格模式this指向</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 前端面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试常见问题</title>
      <link href="/2020/09/14/qian-duan-mian-shi-chang-jian-wen-ti/"/>
      <url>/2020/09/14/qian-duan-mian-shi-chang-jian-wen-ti/</url>
      
        <content type="html"><![CDATA[<style>    .context{        font-size:13pt;    }    .m-context{        font-size: 12pt;    }</style><h2>1、行内元素、块级元素、行内块状元素</h2><div class="context">HTML可以将元素分类方式分为行内元素、块状元素和行内块状元素三种。可以使用display属性能够将三者任意转换：<br/>(1) display:inline; 转换为行内元素<br/>(2) display:block;转换为块状元素<br/>(3) display:inline-block;转换为行内块状元素<br/></div><h3>1.1 行内元素</h3><div class="m-context">特点：<br/>(1) 设置宽高无效<br/>(2) 对margin仅设置左右方向有效，上下无效<br/>(3) 不会自动进行换行<br/>常见行内元素：b、button、input、label、select、textarea、i、small、abbr、strong、a、br、img、map、object、q、script、span、sub、sup</div><h3>1.2 块级元素</h3><div class="m-context">特点：<br/>(1) 能够识别宽高<br/>(2) margin、padding的上下左右均对其有效<br/>(3) 可以自动换行<br/>(4) 多个块状元素标签写在一起，默认排列方式为从上至下<br/>常见块级元素：address、article、aside、audio、video、blackquote、canvas、dd（定义列表条目描述）div、dl、fieldset（表单元素分组）、figcaption（图文信息组标题）、figure、header、footer、form、h1-h6、hr、hgroup、ol、ul、output、p、pre、section、table</div><h3>1.3 行内块状元素</h3><div class="m-context">特点：<br/>(1) 不自动换行<br/>(2) 能识别宽高<br/>(3) 默认排列方式为从左到右<br/>常见行内块状元素：button、object、map</div><h2>2、原型</h2><div class="context">JavaScript 只有一种结构：对象。每个实例对象（ object ）都有一个私有属性（称之为 __proto__ ）指向它的构造函数的原型对象（prototype ）。<br/></div><h3>2.1 _proto_ 与 prototype区别</h3><div class="m-context">两者都是对象的属性<br/>_proto_（隐式原型）是每个对象都有的一个属性，指向该对象的构造函数的原型对象<br/>prototype（显示原型）函数才有的属性，指向该方法的原型对象<br/>具体可见<a>https://mp.weixin.qq.com/s/St78Y38j3XI2_Zv57bNZ0Q</a></div><h2>3、样式优先级</h2><div class="context">内联样式>id选择器(#example)>类选择器(.example)、属性选择器[type="radio"]、伪类(:hover)>类型选择器(h1)、伪元素(::before)<br/>!important例外规则：在一个样式声明中使用该规则时，此声明将覆盖任何其他声明。!important破坏了样式表中固有的级联规则，应该减少使用。</div><h2>4、判断类型</h2><div class="context"> <b>基本类型(存储在栈)：</b>String、Number、Boolean、Null、Undefined、Symbol<br/> <b>引用类型(存储在堆heap)：</b>Object(Function、Array、RegExp、Date)<br/></div> <h3>4.1 typeof</h3> <div class="m-context">    返回的结果用该类型的字符串(全小写字母)形式表示，    包括以下 7 种：number、boolean、symbol、string、object、undefined、function<br/>    注意：    <li>对于基本类型，除 null 以外，均可以返回正确的结果。</li>    <li>对于引用类型，除 function 以外，一律返回 object 类型。</li>    <li>对于 null ，返回 object 类型</li>    <li>对于 function 返回  function 类型。</li> </div> <h3>4.2 instanceof</h3> <div class="m-context"> instanceof 是用来判断 A 是否为 B 的实例,<b>instanceof检测的是原型， 两个对象是否属于实例关系，不能判断属于那种类型</b>， 返回true、false<br/> 举例： <pre><code>[] instanceof Array; &#x2F;&#x2F; true{} instanceof Object;&#x2F;&#x2F; truenewDate() instanceof Date;&#x2F;&#x2F; true function Person(){};newPerson() instanceof Person; [] instanceof Object; &#x2F;&#x2F; truenewDate() instanceof Object;&#x2F;&#x2F; truenewPerson instanceof Object;&#x2F;&#x2F; true</code></pre> </div> <h3>4.3 constructor</h3> <div class="m-context"> 当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。<br/> <img src="/img/proto_constructor.png"> <br/> 注意： <li>1. null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</li> <li>2. 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</li> 因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。 </div> <h3>4.4 toString</h3> <div class="m-context"> toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。<br/> 对于 Object 对象，直接调用 toString()  就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。<br/> 如： <pre><code>Object.prototype.toString.call(&#39;&#39;) ;   &#x2F;&#x2F; [object String]Object.prototype.toString.call(1) ;    &#x2F;&#x2F; [object Number]Object.prototype.toString.call(true) ; &#x2F;&#x2F; [object Boolean]Object.prototype.toString.call(Symbol()); &#x2F;&#x2F;[object Symbol]Object.prototype.toString.call(undefined) ; &#x2F;&#x2F; [object Undefined]Object.prototype.toString.call(null) ; &#x2F;&#x2F; [object Null]Object.prototype.toString.call(newFunction()) ; &#x2F;&#x2F; [object Function]Object.prototype.toString.call(newDate()) ; &#x2F;&#x2F; [object Date]Object.prototype.toString.call([]) ; &#x2F;&#x2F; [object Array]Object.prototype.toString.call(newRegExp()) ; &#x2F;&#x2F; [object RegExp]Object.prototype.toString.call(newError()) ; &#x2F;&#x2F; [object Error]Object.prototype.toString.call(document) ; &#x2F;&#x2F; [object HTMLDocument]Object.prototype.toString.call(window) ; &#x2F;&#x2F;[object global] window 是全局对象 global 的引用</code></pre> </div> 参考：<a>https://www.cnblogs.com/onepixel/p/5126046.html</a><h2>5、CSS度量单位、区别</h2><div class="context">绝对长度单位：px、in、cm、mm<br/>相对长度单位：em、rem、ex、ch<br/></div><h3>px、em、rem的区别</h3>px：px采用参考像素，值是<b>固定</b>的<br/>em：<b>相对于当前元素的字体大小属性计算出来</b>，1em=16px，如果当前元素没有设置字体大小，依赖其父元素大小，依次类推直至找到能计算的元素<br/>rem:与em类似，但是是<b>相对根元素进行计算</b>。只要在html元素指定字体大小，后面元素都将使用这个大小作为基准进行计算,<b>此单位经常被用来做屏幕适配，保证不同设备下的显示效果。</b><h2>6、new操作符步骤</h2><div class="context">new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。<br/><br/><b>new 关键字会进行如下的操作：<li> 创建一个空的简单JavaScript对象（即{}）；</li><li> 链接该对象（设置该对象的constructor）到另一个对象 ；</li><li> 将步骤1新创建的对象作为this的上下文 ；</li><li> 如果该函数没有返回对象，则返回this。</li></b>创建一个用户自定义对象需要两步：<br/>1、通过编写函数来定义对象类型<br/>2、通过new来创建对象实例</div><h2>7、二叉树遍历方法</h2><div class="context"><li>前序遍历：根结点-->左子树-->右子树</li><li>中序遍历：左子树-->根结点-->右子树</li><li>后序遍历：左子树-->右子树-->根结点</li><li>层次遍历</li></div><h2>8、cookie、localStorage、sessionStorage区别</h2><img src="/img/cookieLocalstorage.jpg"/><h2>9、html5的新元素、新属性</h2><div class="context"><li>canvas:标签定义图形</li></div><h3>新多媒体元素</h3><div class="context"><li>audio:音频</li><li>video:视频</li><li>source:定义多媒体资源audio和video</li><li>embed:定义嵌入的内容，如插件</li><li>track:为video和audio之类的媒介规定外部文本轨道</li></div><h3>新表单元素</h3><div class="context"><li>datalist:定义选项列表，与input配合使用</li><li>keygen:规定表单的密钥对生成器字段</li><li>output:定义不同类型的输出</li></div><h3>新的语义和结构元素</h3><div class="context"><li>article:定义页面独立的内容区域</li><li>aside:定义页面的侧边栏内容</li><li>bdi:允许您设置一段文本，使其脱离其父元素的文本方向设置</li><li>command:定义命令按钮，比如单选按钮、复选框或按钮</li><li>details:用于描述文档或文档某个部分的细节</li><li>dialog:定义对话框，比如提示框</li><li>summary:标签包含 details 元素的标题</li><li>figure/figcaption:规定独立的流内容/figure的标题</li><li>footer/header:定义 section 或 document 的页脚/文档头部</li><li>mark:定义带有记号的文本。</li><li>meter:定义度量衡。仅用于已知最大和最小值的度量。</li><li>nav:定义导航链接的部分。</li><li>progress:定义任何类型的任务的进度。</li><li>ruby/rt:定义 ruby 注释（中文注音或字符）/字符（中文注音或字符）的解释或发音</li><li>rp:在 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容</li><li>section:定义文档中的节（section、区段）</li><li>time:定义日期或时间</li><li>wbr:规定在文本中的何处适合添加换行符</li></div><h3>已移除的元素</h3><div class="context">acronym、applet、basefont、big、center、dir、font、frame、frameset、noframes、strike、tt、</div><h2>10、闭包</h2><div class="context">闭包可以让你从内部函数访问外部函数作用域。<br/>举例：<pre><code>function makeFunc() {    var name &#x3D; &quot;Mozilla&quot;;    function displayName() {        alert(name);    }    return displayName;}var myFunc &#x3D; makeFunc();myFunc();</code></pre></div>]]></content>
      
      
      
        <tags>
            
            <tag> 前端面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习（三）</title>
      <link href="/2020/07/09/vue-xue-xi-san/"/>
      <url>/2020/07/09/vue-xue-xi-san/</url>
      
        <content type="html"><![CDATA[<h3>一、 项目开发的步骤</h3><li style="font-size: large">1.1 划分目录结构</li>1.1.1 assets文件夹：放入类似css、img文件夹<br>1.1.2 common文件夹：项目的公共数据，比如公共变量、方法<br>1.1.3 components文件夹：项目的组件，一般里面又分为两个文件夹，common（其他项目也可以用的组件）、content（只有此项目用的组件）<br>1.1.4 network文件夹：网络目录<br>1.1.5 router文件夹：路由目录<br>1.1.6 store文件夹：仓库目录<br>1.1.6 views文件夹：大的视图块<br><li style="font-size: large">1.2 引用css文件</li><br><li style="font-size: large">1.3 设置别名</li><li>在文件中创建vue.config.js文件，router和store可以不设置别名</li><li>设置.editorconfig文件</li><br><li style="font-size: large">1.4 项目的模块划分：路由映射关系</li>]]></content>
      
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习（二）</title>
      <link href="/2020/06/28/vue-xue-xi-er/"/>
      <url>/2020/06/28/vue-xue-xi-er/</url>
      
        <content type="html"><![CDATA[<h3>1.1 过滤器：</h3><h4>在js中使用filters设置，运用‘item|过滤器’</h4><h3>1.2 v-model：</h3><h4>v-model指令可以实现表单元素和数据的双向绑定，如：动态得到输入框(input、textarea)的值</h4><h4>v-model其实是一个语法糖，它的背后本质上是包含两个操作：</h4>    <li>1.v-bind绑定一个value属性，得到值</li>    <li>2.v-on指令给当前元素绑定input事件，监听值的改变</li><pre><code>&lt;input type&#x3D;&quot;text&quot; v-bind:value&#x3D;&quot;message&quot; v-on:input&#x3D;&quot;message &#x3D; $event.target.value&quot;&gt;</code></pre><h4>1.2.1 v-model案例</h4>单选框<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;v-model结合radio&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--    使用name使单选框只能选一个--&gt;    &lt;label for&#x3D;&quot;male&quot;&gt;        &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;male&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;男&quot; v-model&#x3D;&quot;sex&quot;&gt;男    &lt;&#x2F;label&gt;    &lt;label for&#x3D;&quot;female&quot;&gt;        &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;female&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;女&quot; v-model&#x3D;&quot;sex&quot;&gt;女    &lt;&#x2F;label&gt;    &lt;br&gt;    &lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;,            sex: &#39;男&#39;        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><br>复选框<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;v-model结合checkbox&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--  checkbox单选框  --&gt;    &lt;!--    &lt;label for&#x3D;&quot;license&quot;&gt;--&gt;    &lt;!--        &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;license&quot; v-model&#x3D;&quot;isAgree&quot;&gt;同意协议--&gt;    &lt;!--    &lt;&#x2F;label&gt;--&gt;    &lt;!--    &lt;h2&gt;&lt;&#x2F;h2&gt;--&gt;    &lt;!--    &lt;button :disabled&#x3D;&quot;!isAgree&quot;&gt;下一步&lt;&#x2F;button&gt;--&gt;    &lt;!--    &lt;br&gt;--&gt;    &lt;!--    --&gt;    &lt;!--  checkbox多选框  --&gt;    &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;篮球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;篮球    &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;足球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;足球    &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;乒乓球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;乒乓球    &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;羽毛球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;羽毛球    &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;网球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;网球    &lt;br&gt;    &lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;,            isAgree: false,&#x2F;&#x2F;单选框            hobbies: []&#x2F;&#x2F;多选框        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4>1.2.2 v-model修饰符</h4><h5>lazy修饰符：</h5>默认情况下，v-model默认是在input事件中同步输入框的数据的。也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。<br>lazy修饰符可以让数据在失去焦点或者回车时才会更新<h5>number修饰符：</h5>默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。<br>number修饰符可以让在输入框中输入的内容自动转成数字类型<h5>trim修饰符：</h5>如果输入的内容首尾有很多空格，通常我们希望将其去除<br>trim修饰符可以过滤内容左右两边的空格<h3>1.3 组件化</h3><h4>1.3.1 概念</h4>如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。<br>但如果，我们将一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了。<h4>1.3.2 注册组件的基本步骤</h4><li>创建组件构造器(调用Vue.extend()方法)</li><li>注册组件(调用Vue.component()方法)</li><li>使用组件(在Vue实例的作用范围内使用)</li>1.Vue.extend()：调用Vue.extend()创建的是一个组件构造器。 <br>通常在创建组件构造器时，传入<b>template</b>代表我们自定义组件的模板。该模板就是在使用到组件的地方，要显示的HTML代码。<br>2.Vue.component()：调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。所以需要传递两个参数：1、注册组件的标签名 2、组件构造器<br>3.组件必须挂载在某个Vue实例下，否则它不会生效。<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;vue组件化基本使用&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--3.使用组件--&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;cpn&gt;&lt;&#x2F;cpn&gt;    &lt;cpn&gt;&lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;ES6    &#x2F;&#x2F;1.创建组件构造器对象    const cpnC &#x3D; Vue.extend({        template: &#96;&lt;div&gt;    &lt;h2&gt;我是标题&lt;&#x2F;h2&gt;    &lt;p&gt;我是内容1&lt;&#x2F;p&gt;    &lt;p&gt;我是内容2&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&#96;    })    &#x2F;&#x2F;2.注册组件    &#x2F;&#x2F; Vue.component(&#39;组件标签名&#39;,&#39;创建的组件名字&#39;)    Vue.component(&#39;cpn&#39;, cpnC)    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4>1.3.3 父组件和子组件</h4><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;父组件与子组件&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;cpn2&gt;&lt;&#x2F;cpn2&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F; 1.创建第一个组件（子组件）    const cpnC1 &#x3D; Vue.extend({        template: &#96;        &lt;div&gt;        &lt;h2&gt;我是标题啊1&lt;&#x2F;h2&gt;        &lt;p&gt;我是内容！！！！&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&#96;    })    &#x2F;&#x2F; 2.创建第二个组件（父组件）    const cpnC2 &#x3D; Vue.extend({        template: &#96;        &lt;div&gt;        &lt;h2&gt;我是标题啊2&lt;&#x2F;h2&gt;        &lt;p&gt;我是内容！！！！2222&lt;&#x2F;p&gt;        &lt;cpn1&gt;&lt;&#x2F;cpn1&gt;&lt;&#x2F;div&gt;&#96;,        components:{            cpn1:cpnC1        }    })    &#x2F;&#x2F;root组件    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;        },        components:{            cpn2:cpnC2        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4>1.3.4 组件的语法糖和模板分离</h4>1.全局组件注册的语法糖Vue.component('组件签名',{组件内容})<br>2.局部组件注册的语法糖component:{'组件签名',{组件内容}}<br>模板分离两种方法：<br>1.使用scrpit,类型text/x-template标签<br>2.使用template标签<h4>1.3.5 组件数据的存放</h4>组件不能直接访问Vue实例的数据（data）<h5>使用方法：在组件注册时定义数据，并有返回值</h5><pre><code>Vue.component(&#39;cpn&#39;, {    template: &#39;#cpn&#39;,    data(){        return {            title:&#39;hahhahahahhhh&#39;        }    }})</code></pre><h4>1.3.6 父子组件的通信</h4><li>通过props向子组件传递数据</li><li>通过事件($emit Events)向父组件发送消息</li><h5> 1.3.6.1 父向子传数据（props）</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;父组件向子组件传递数据&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--    注意：要使用v-bind绑定数据--&gt;    &lt;cpn :vmovies&#x3D;&quot;movies&quot; :cm&#x3D;&quot;message&quot;&gt;&lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li v-for&#x3D;&quot;item in vmovies&quot;&gt;&lt;&#x2F;li&gt;        &lt;&#x2F;ul&gt;            &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F; 父传子，props    const cpn &#x3D; {        template: &#39;#cpn&#39;,        &#x2F;&#x2F; 通过数组        &#x2F;&#x2F; props: [&#39;vmovies&#39;, &#39;cm&#39;],        &#x2F;&#x2F; 通过对象        props: {            &#x2F;&#x2F; 1.类型限制            &#x2F;&#x2F; vmoives: Array,            &#x2F;&#x2F; cm:String                        &#x2F;&#x2F; 2.提供一些默认值，required设置必传值            cm:{                type:String,                default:&#39;aaaaaaaaa&#39;,                required:true            },            &#x2F;&#x2F; 类型是对象或者数组时，默认值是一个函数            vmovies:{                type:Array,                default(){                    return []                }            }        },        data() {            return {}        },        methods: {}    }    const app &#x3D; new Vue({        el: &#39;#app&#39;,        &#x2F;&#x2F; 父组件的数据        data: {            message: &#39;你好啊&#39;,            movies: [&#39;海王&#39;, &#39;海贼王&#39;, &#39;海绵宝宝&#39;]        },        components: {            &#x2F;&#x2F; 增强写法，本是&#39;cpn&#39;:cpn            cpn        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h5> 1.3.6.2 子向父传数据（$emit()发射事件）</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;子传父&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--父组件模板--&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--    监听子组件发送的事件--&gt;    &lt;cpn @itemclick&#x3D;&quot;cpnClick&quot;&gt;&lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt;&lt;!--子组件模板--&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt;    &lt;div&gt;        &lt;button v-for&#x3D;&quot;item in categories&quot; @click&#x3D;&quot;btnClick(item)&quot;&gt;&lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;子组件    const cpn &#x3D; {        template: &#39;#cpn&#39;,        data() {            return {                categories: [                    {id: &#39;aaa&#39;, name: &#39;热门推荐&#39;},                    {id: &#39;bbb&#39;, name: &#39;手机数码&#39;},                    {id: &#39;ccc&#39;, name: &#39;家用电器&#39;},                    {id: &#39;ddd&#39;, name: &#39;电脑办公&#39;},                ]            }        },        methods: {            btnClick(item) {                &#x2F;&#x2F; 发射事件，&#39;事件名称&#39;,值                this.$emit(&#39;itemclick&#39;, item)            }        }    }    &#x2F;&#x2F;父组件    const app &#x3D; new Vue({        el: &#39;#app&#39;,        &#x2F;&#x2F; 父组件的数据        data: {            message: &#39;你好啊&#39;,            movies: [&#39;海王&#39;, &#39;海贼王&#39;, &#39;海绵宝宝&#39;]        },        components: {            &#x2F;&#x2F; 增强写法，本是&#39;cpn&#39;:cpn            cpn        },        methods: {            cpnClick(item) {                console.log(item)            }        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h5> 1.3.6.3 父子间相互传递数据</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;父子组件通信&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;cpn :number1&#x3D;&quot;num1&quot;         :number2&#x3D;&quot;num2&quot;         @num1change&#x3D;&quot;num1change&quot;         @num2change&#x3D;&quot;num2change&quot;&gt;&lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt;    &lt;div&gt;        &lt;h2&gt;props:&lt;&#x2F;h2&gt;        &lt;h2&gt;data:&lt;&#x2F;h2&gt;        &lt;!--        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;dnumber1&quot;&gt;--&gt;        &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;dnumber1&quot; @input&#x3D;&quot;num1Input&quot;&gt;        &lt;h2&gt;props:&lt;&#x2F;h2&gt;        &lt;h2&gt;data:&lt;&#x2F;h2&gt;        &lt;!--        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;dnumber2&quot;&gt;--&gt;        &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;dnumber2&quot; @input&#x3D;&quot;num2Input&quot;&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            num1: 1,            num2: 0        },        methods: {            num1change(value) {                this.num1 &#x3D; parseFloat(value)            },            num2change(value) {                this.num2 &#x3D; parseFloat(value)            }        },        components: {            cpn: {                template: &#39;#cpn&#39;,                props: {                    number1: Number,                    number2: Number                },                data() {                    return {                        dnumber1: this.number1,                        dnumber2: this.number2                    }                },                methods: {                    num1Input(event) {                        &#x2F;&#x2F; 1.将input中的value复制到dnumber                        this.dnumber1 &#x3D; event.target.value;                        &#x2F;&#x2F; 2.为了让父组件可以修改值，发出一个事件                        this.$emit(&#39;num1change&#39;, this.dnumber1)                        &#x2F;&#x2F; 3.同时修饰dnumber2的值                        this.dnumber2 &#x3D; this.dnumber1 * 100;                        this.$emit(&#39;num2change&#39;,this.dnumber2)                    },                    num2Input(event) {                        this.dnumber2 &#x3D; event.target.value                        this.$emit(&#39;num2change&#39;, this.dnumber2)                        this.dnumber1 &#x3D; this.dnumber2 &#x2F; 100;                        this.$emit(&#39;num1change&#39;,this.dnumber1)                    }                }            }        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4> 1.3.7 父子组件的访问方式</h4><h5>有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问跟组件。<br>    <br><li>父组件访问子组件：使用$children或$refs</li>    <br><li>子组件访问父组件：使用$parent</li></h5><br><h5>1.3.7.1 父组件访问子组件 $children和$refs（推荐）的使用</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;父访问子-children-refs&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;cpn&gt;&lt;&#x2F;cpn&gt;    &lt;cpn&gt;&lt;&#x2F;cpn&gt;    &lt;cpn ref&#x3D;&quot;aaa&quot;&gt;&lt;&#x2F;cpn&gt;    &lt;button @click&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt;    &lt;div&gt;我是子组件&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;        },        methods: {            btnClick() {                &#x2F;&#x2F; 1.$children                &#x2F;&#x2F; console.log(this.$children);                &#x2F;&#x2F; this.$children[0].showMessage()                &#x2F;&#x2F; console.log(this.$children[0].name);                &#x2F;&#x2F; 2.$refs（推荐）-&gt;对象类型，默认是空对象，设置ref                console.log(this.$refs.aaa.name);            }        },        components: {            cpn: {                template: &#39;#cpn&#39;,                data() {                    return {                        name: &#39;我是子组件的name&#39;                    }                },                methods: {                    showMessage() {                        console.log(&#39;showMessage&#39;)                    }                }            }        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h5>1.3.7.2 子组件访问父组件 $parent和$root的使用</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;组件访问-子组件访问父组件&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;cpn&gt;&lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt;    &lt;div&gt;        我是cpn组件        &lt;ccpn&gt;&lt;&#x2F;ccpn&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;template id&#x3D;&quot;ccpn&quot;&gt;    &lt;div&gt;        &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;        &lt;button @click&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;        },        components: {            cpn: {                template: &#39;#cpn&#39;,                components: {                    ccpn: {                        template: &#39;#ccpn&#39;,                        methods: {                            btnClick() {                                &#x2F;&#x2F;1.访问父组件$parent                                console.log(this.$parent)                                console.log(this.$parent.name)                                &#x2F;&#x2F;2.访问root组件                                console.log(this.$root)                                console.log(this.$root.message)                            }                        }                    }                }            },        },    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4>1.3.8 插槽slot</h4><h5>多处使用一个模板，但功能不同，可以使用插槽定义（占位），后在具体应用中设置不同的功能</h5><h5>插槽中可以定义默认值，之后使用重新定义可替换默认的功能</h5><h5>具名插槽：给插槽定义name，使用是在标签内说明slot='name名字'，可以分辨不同的slot</h5><br>作用域插槽<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;作用域插槽&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;cpn&gt;&lt;&#x2F;cpn&gt;    &lt;cpn&gt;        &lt;!--目的：获取子组件的pLanguage--&gt;        &lt;template slot-scope&#x3D;&quot;slot&quot;&gt;            &lt;!--&lt;span v-for&#x3D;&quot;item in slot.data&quot;&gt; - &lt;&#x2F;span&gt;--&gt;            &lt;!--使用join连接字符串--&gt;            &lt;span&gt;slot.data.join(&#39; - &#39;)&lt;&#x2F;span&gt;        &lt;&#x2F;template&gt;    &lt;&#x2F;cpn&gt;    &lt;cpn&gt;        &lt;!-- 目的：得到子组件的pLanguage--&gt;        &lt;template slot-scope&#x3D;&quot;slot&quot;&gt;            &lt;span v-for&#x3D;&quot;item in slot.data&quot;&gt; --&#x3D;&lt;&#x2F;span&gt;        &lt;&#x2F;template&gt;    &lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt;    &lt;div&gt;        &lt;!--data可改为自定义名字，获取组件中pLanguage数据--&gt;        &lt;slot :data&#x3D;&quot;pLanguage&quot;&gt;            &lt;ul&gt;                &lt;li v-for&#x3D;&quot;item in pLanguage&quot;&gt;&lt;&#x2F;li&gt;            &lt;&#x2F;ul&gt;        &lt;&#x2F;slot&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;        },        components: {            cpn: {                template: &#39;#cpn&#39;,                data() {                    return {                        pLanguage: [&#39;JavaScrpit&#39;, &#39;C++&#39;, &#39;Python&#39;, &#39;C#&#39;, &#39;Go&#39;]                    }                }            }        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4>1.3.9 模块化开发</h4><h5>常见的模块化规范：CommonJS,AMD,CMD,ES6的Modules</h5><h4>1.3.10 Webpack</h4><h5>webpack是一个现代的JavaScript应用的静态模块打包工具。</h5><h5>插件：对某个现有的框架进行扩展</h5><h3>1.4 Vue cli（脚手架）</h3>使用vue init webpack my-project(vue cli2)或者vue create my-project(vue cli3)初始化项目<h4>Vue cli2</h4><img src="/img/vuecli01.png"><h4>Vue cli3</4><img src="/img/vuecli02.png"><h4>Runtime-Compiler和Runtime-only的区别</h4><br>两者在main.js中不同<li>如果在之后的开发中，你依然使用template，就需要选择Runtime-Compiler</li><li>如果你之后的开发中，使用的是.vue文件夹开发，那么可以选择Runtime-only</li><br><b>runtimecompiler：</b><br>template->ast->render->vdom->UI<b><br>runtimeonly：（性能更高，代码量更少）</b><br>render->vdom->UI<h3>1.5 vue-router（路由）</h3><h4>后端路由：后端处理URL和页面之间的映射关系</h4><h4>前后端分离：有ajax，前端url发送到静态资源服务器</h4><h4>前端路由：前端管理映射关系，抽取一部分js代码处理</h4><h4>1.5.1 改变URL，但是页面不进行整体的刷新的实现</h4><li>url的hash：location.hash='/foo'，直接改变href</li><li>html5的history模式：</li><li>(1)history.pushState({},'','/foo')，可以返回</li><li>(2)history.replaceState({},'','/foo')，不可以返回</li><li>(3)history.go(-1)</li><li>(4)history.back() 等价于 history.go(-1),history.forward() 则等价于 history.go(1)</li><h4>1.5.2 动态路由：</h4><li>在配置路由和组件映射关系式，path中，路径后加上'/:变量名'</li><li>在app.vue中，绑定事件，在路径后面加上变量名，如:v-bind:to="'/user/'+userId"</li><li>若要在页面显示变量，可以使用$route.params.变量名，获得当前活跃的路由，注意是route（路由），不是router（路由器）</li><h4>1.5.3 路由懒加载</h4><h5>懒加载：需要用到时才进行加载</h5><h5>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块,只有在这个路由被访问到的时候, 才加载对应的组件</h5><h5>出去三个对应的js文件，有几个组件就打包成对应的js代码块</h5><li>方式一：结合Vue的异步组件和Webpack的代码分析.</li>const Home = resolve => { require.ensure(['../components/Home.vue'], () => { resolve(require('../components/Home.vue')) })};<li>方式二: AMD写法:</li>const About = resolve => require(['../components/About.vue'], resolve);<li>方式三: 在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割.</li>const Home = () => import('../components/Home.vue')<h4>1.5.4 $route和$router的区别</h4>$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法$route为当前router跳转对象里面可以获取name、path、query、params等<h4>1.5.5 导航守卫</h4> vue-router提供的导航守卫主要用来监听监听路由的进入和离开的.vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发.<h4>1.5.6 keep-alive</h4> 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<h5>属性：</h5><li>include - 字符串或正则表达，只有匹配的组件会被缓存</li><li>exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</li><h3>1.6 Promise</h3><h4>1.6.1 什么情况会用到promise？</h4>一般情况下是有异步操作时，使用promise对这个异步操作进行封装<pre><code>&#x2F;&#x2F; 什么情况会用到promise?    &#x2F;&#x2F; 一般情况下是有异步操作时，使用promise对这个异步操作进行封装    &#x2F;&#x2F; new-&gt;执行构造函数（1 保存了一些状态信息 2.执行传入函数）    &#x2F;&#x2F; 在执行传入的回调函数时，会传入两个参数，resolve，reject本身也是函数    new Promise((resolve, reject) &#x3D;&gt; {        setTimeout(() &#x3D;&gt; {            &#x2F;&#x2F; 成功时调用resolve            &#x2F;&#x2F; resolve(&#39;Hello world&#39;)            &#x2F;&#x2F; 失败时调用reject            reject(&#39;error message&#39;)        }, 1000)    }).then((data) &#x3D;&gt; {        console.log(data);        console.log(data);        console.log(data);        console.log(data);    }).catch((err) &#x3D;&gt; {        console.log(err);    })</code></pre><h4>1.6.2 promise的三种状态</h4><li>(1) pending: 等待状态，比如正在进行网络请求，或者定时器没有到时间。</li><li>(2) fulfill: 满足状态，当我们主动回调了resolve时，就处于该状态，并且会回调.then()</li><li>(3) reject: 拒绝状态，当我们主动回调了reject时，就处于该状态，并且会回调.catch()</li><p>最简化代码</p><pre><code>&#x2F;&#x2F; 最简化    new Promise((resolve, reject) &#x3D;&gt; {        setTimeout(() &#x3D;&gt; {            resolve(&#39;aaa&#39;)        }, 1000)    }).then(res &#x3D;&gt; {        &#x2F;&#x2F; 自己处理10行代码        console.log(res, &#39;第一层代码&#39;);&#x2F;&#x2F; 2.对结果处理        return res + &#39;111&#39;    }).then(res &#x3D;&gt; {        console.log(res, &#39;第二层&#39;);        return Promise.reject(&#39;error message&#39;)    }).then(res &#x3D;&gt; {        console.log(res, &#39;第三层代码&#39;);    })</code></pre><h3>1.7 Vuex</h3><h5>vuex是一个专门为vue.js应用程序开发的状态管理模式</h5><h4>1.7.1 管理什么状态？</h4><li>用户的登录状态、用户名称、头像、地理位置信息等等。</li><li>商品的收藏、购物车中的物品等等。</li>    这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的。<h4>1.7.2 Vuex几个核心的概念</h4><li>State</li><li>Getters</li><li>Mutation</li><li>Action</li><li>Module</li><h5>1.7.2.1 State单一状态树</h5>单一数据源，管理应用层的全部状态，让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。<h5>1.7.2.2 Getters</h5>类似于计算属性<h6>index.js</h6><pre><code>import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)const store &#x3D; new Vuex.Store({  state: {    counter: 1000,    students: [      {id: 110, name: &#39;why&#39;, age: 23},      {id: 112, name: &#39;Mois&#39;, age: 20},      {id: 113, name: &#39;dimmo&#39;, age: 10},      {id: 114, name: &#39;Molly&#39;, age: 19}    ]  },  getters: {    powerCounter(state) {      return state.counter * state.counter    },    more20stu(state) {      return state.students.filter(s &#x3D;&gt; s.age &gt; 10)    },    more20stuLength(state, getters) {      return getters.more20stu.length    },    moreAgestu(state) {      return function (age) {        return state.students.filter(s &#x3D;&gt; s.age &gt; age)      }    }  },  modules: {}})export default store</code></pre><h6>App.vue</h6><pre><code>&lt;template&gt;  &lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h2&gt;---------App内容:getters相关信息-------------&lt;&#x2F;h2&gt;    &lt;h2&gt;$store.getters.powerCounter&lt;&#x2F;h2&gt;    &lt;h2&gt;$store.getters.more20stu&lt;&#x2F;h2&gt;    &lt;h2&gt;$store.getters.more20stuLength&lt;&#x2F;h2&gt;    &lt;h2&gt;$store.getters.moreAgestu(9)&lt;&#x2F;h2&gt;&lt;!--    &lt;h2&gt;$store.getters.more20stu.length&lt;&#x2F;h2&gt;--&gt;    &lt;h2&gt;---------HelloVuex内容-------------&lt;&#x2F;h2&gt;    &lt;hello-vuex&#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  import HelloVuex from &quot;.&#x2F;components&#x2F;HelloVuex&quot;;    export default {        name: &#39;App&#39;,        components:{            HelloVuex        },        data() {            return {                message: &#39;我是app组件&#39;,                counter:0            }        }    }&lt;&#x2F;script&gt;</code></pre><h5>1.7.2.3 Mutation</h5><h6>Vuex的store状态的更新唯一方式：提交Mutation</h6><h6>Mutation主要包括两部分：</h6><li>字符串的事件类型（type）</li><li>一个回调函数（handler）,该回调函数的第一个参数就是state。</li><h6>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新.</h6>这就要求我们必须遵守一些Vuex对应的规则:<li>提前在store中初始化好所需的属性.</li><li>当给state中的对象添加新属性时, 使用下面的方式:</li>方式一: 使用Vue.set(obj, 'newProp', 123)<br>方式二: 用心对象给旧对象重新赋值<br>删除使用Vue.deleteindex.js<pre><code>import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)const store &#x3D; new Vuex.Store({  state: {    counter: 1000,    students: [      {id: 110, name: &#39;why&#39;, age: 23},      {id: 112, name: &#39;Mois&#39;, age: 20},      {id: 113, name: &#39;dimmo&#39;, age: 10},      {id: 114, name: &#39;Molly&#39;, age: 19}    ]  },  &#x2F;&#x2F; 同步操作  mutations: {    increment(state) {      state.counter++    },    decrement(state) {      state.counter--    },    incrementCount(state, payload) {      &#x2F;&#x2F; state.counter +&#x3D; payload      console.log(&quot;payloas&quot;,payload);      console.log(&quot;count:&quot;,payload.count);      state.counter +&#x3D; payload.count    },    addStudent(state,stu){      state.students.push(stu)    }  }  },  modules: {}})export default store</code></pre><p>app.vue</p><pre><code>&lt;template&gt;  &lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h2&gt;---------App内容-------------&lt;&#x2F;h2&gt;    &lt;h2&gt;&lt;&#x2F;h2&gt;    &lt;button @click&#x3D;&quot;addition&quot;&gt;+&lt;&#x2F;button&gt;    &lt;button @click&#x3D;&quot;subtraction&quot;&gt;-&lt;&#x2F;button&gt;    &lt;button @click&#x3D;&quot;addCount(5)&quot;&gt;+5&lt;&#x2F;button&gt;    &lt;button @click&#x3D;&quot;addCount(10)&quot;&gt;+10&lt;&#x2F;button&gt;    &lt;button @click&#x3D;&quot;addStudent&quot;&gt;添加学生&lt;&#x2F;button&gt;&lt;!--    &lt;h2&gt;&lt;&#x2F;h2&gt;--&gt;    &lt;h2&gt;---------HelloVuex内容-------------&lt;&#x2F;h2&gt;    &lt;hello-vuex&#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  import HelloVuex from &quot;.&#x2F;components&#x2F;HelloVuex&quot;;    export default {        name: &#39;App&#39;,        components:{            HelloVuex        },        data() {            return {                message: &#39;我是app组件&#39;,                counter:0            }        },        methods:{            addition(){                &#x2F;&#x2F; 括号内为方法名                this.$store.commit(&#39;increment&#39;)            },            subtraction(){                this.$store.commit(&#39;decrement&#39;)            },            addCount(count){                &#x2F;&#x2F; 1、普通提交风格                &#x2F;&#x2F; this.$store.commit(&#39;incrementCount&#39;,count)                &#x2F;&#x2F; 2.特殊的提交封装                this.$store.commit({                    type:&#39;incrementCount&#39;,                    count                })            },            addStudent(){                const stu &#x3D;{id:114,name:&#39;alan&#39;,age:33}                this.$store.commit(&#39;addStudent&#39;,stu)            }        }    }&lt;&#x2F;script&gt;</code></pre><li>字符串的事件类型（type）</li><li>一个回调函数（handler）,该回调函数的第一个参数就是state。</li><h5>1.7.2.4 Action</h5>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.调用action方法时要用dispatch<pre><code>mutations: {    updateName(state,payload){      state.name&#x3D;payload    }  },  &#x2F;&#x2F; 异步操作  actions: {    aUpdateName(context){      setTimeout(()&#x3D;&gt;{        context.commit(&#39;updateName&#39;,&#39;xixiximois&#39;)      },1000)    }  }    &#x2F;&#x2F;调用  updateName(){                  this.$store.commit(&#39;updateName&#39;,&#39;hahamois&#39;)              },  </code></pre><h5>1.7.2.5 Module</h5>声明一个模块，局部通过context.state暴露，根结点状态为context.rootState<pre><code>const moduleA&#x3D;{  state: {    name:&#39;MMMois&#39;  },  &#x2F;&#x2F; 同步操作  mutations: {    updateName(state,payload){      state.name&#x3D;payload    }  },  &#x2F;&#x2F; 异步操作  actions: {    aUpdateName(context){      setTimeout(()&#x3D;&gt;{        context.commit(&#39;updateName&#39;,&#39;xixiximois&#39;)      },1000)    }  },  &#x2F;&#x2F; 类似计算属性  getters: {    fullname(state){      return state.name+&#39;222222&#39;    },    fullname2(state,getters){      return getters.fullname+&#39;333333333&#39;    },    &#x2F;&#x2F; 拼接主模块的内容rootState    fullname3(state,getters,rootState){      return getters.fullname+&#39;333333333&#39;+rootState.counter    }  },}  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6语法（来自b站课件）</title>
      <link href="/2020/06/27/es6-yu-fa-lai-zi-b-zhan-ke-jian/"/>
      <url>/2020/06/27/es6-yu-fa-lai-zi-b-zhan-ke-jian/</url>
      
        <content type="html"><![CDATA[<img src="/img/ES601.png"><img src="/img/ES602.png"><img src="/img/ES603.png">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端基础知识总结</title>
      <link href="/2020/05/12/qian-duan-ji-chu-zhi-shi-zong-jie/"/>
      <url>/2020/05/12/qian-duan-ji-chu-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4>JavaScript面试题</h4><a>https://segmentfault.com/a/1190000015288700</a>]]></content>
      
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 学习（一）</title>
      <link href="/2020/05/12/vue-xue-xi-yi/"/>
      <url>/2020/05/12/vue-xue-xi-yi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css"><script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script><style>.d-list{    font-size: 15pt;    display:list-item;    list-style-position: inside;    list-style-type: circle;}</style><h1>一、认识Vuejs</h1><h3>1.1 Vue是一个渐进式的框架。</h3><h4> 1.1.1 渐进式：</h4><div class="d-list">渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验。</div><div class="d-list">或者如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统。</div><div class="d-list">比如Core+Vue-router+Vuex，也可以满足你各种各样的需求。</div><h3>1.2 第一个Vue实例</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;let（变量）&#x2F;const（常量）    &#x2F;&#x2F;编程范式：声明式编程    const app &#x3D; new Vue({        el: &#39;#app&#39;,&#x2F;&#x2F;用于挂载要管理的元素        data: {&#x2F;&#x2F;定义数据            message: &#39;你好！&#39;        }    })    &#x2F;&#x2F;元素js的做法（编程范式：命令式编程）    &#x2F;&#x2F;1.创建div元素，设置id属性    &#x2F;&#x2F;2.定义一个message变量    &#x2F;&#x2F;3.将message变量放在前面的div元素中显示    &#x2F;&#x2F;4.修改message数据，并替换&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3>1.3 第二个Vue实例-列表</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;ul&gt;        &lt;li v-for&#x3D;&quot;item in movies&quot;&gt;&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            messages: &#39;你好啊&#39;,            movies: [&#39;魔界契约&#39;, &#39;海王&#39;, &#39;哪吒&#39;, &#39;盗墓笔记&#39;]        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3>1.4 第三个Vue实例-计数器</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h2&gt;当前计数：&lt;&#x2F;h2&gt;    &lt;!--    v-on监听--&gt;    &lt;!--    &lt;button v-on:click&#x3D;&quot;counter++&quot;&gt;+&lt;&#x2F;button&gt;--&gt;    &lt;!--    &lt;button v-on:click&#x3D;&quot;counter&amp;#45;&amp;#45;&quot;&gt;-&lt;&#x2F;button&gt;--&gt;    &lt;button v-on:click&#x3D;&quot;add&quot;&gt;+&lt;&#x2F;button&gt;    &lt;button @click&#x3D;&quot;sub&quot;&gt;-&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;语法糖：简写 @click是v-on:click的语法糖    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            counter: &#39;0&#39;        },        methods: {            add: function () {                console.log(&#39;add被执行&#39;)                this.counter++            },            sub: function () {                console.log(&#39;sub被执行&#39;)                this.counter--            }        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3>1.5 MVVM</h3><h4>Model View ViewModel</h4><ul>View层：<li>视图层</li><li>在我们前端开发中，通常就是DOM层。</li><li>主要的作用是给用户展示各种信息。</li></ul><ul>Model层：<li>数据层</li><li>数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。</li><li>在我们计数器的案例中，就是后面抽取出来的obj，当然，里面的数据可能没有这么简单。</li></ul><ul>VueModel层：<li>视图模型层</li><li>视图模型层是View和Model沟通的桥梁。</li><li>一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中</li><li>另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。</li></ul><h3>1.6 开发中什么是函数，什么是方法？</h3><li>函数：function，直接在script里面定义 </li><li>方法：method，一般定义在类里面</li><h3>1.7 vue的生命周期</h3>初始化->更新->死亡<img src="/img/pic01.png"><h3>1.8 模板语法</h3><h4>1.8.1 Mustache语法（双括号）:可以使用简单的表达式</h4><h4>1.8.2 v-once:只渲染一次，之后不会随数据更改，并且后面不跟表达式</h4><h4>1.8.3 v-html：设置有标签的超链接</h4><h4>1.8.4 v-text：类似于Mustache语法，但不可拼接，使用较少</h4><h4>1.8.5 v-pre：原封不动的显示标签内的内容，不用解析</h4><h4>1.8.6 v-cloak：在vue解析之前有效，避免显然出未编译的Mustache标签</h4><h4>1.8.7 v-bind：</h4> <li class="d-list">动态绑定链接属性</li> <li class="d-list">语法糖：':'</li> <li class="d-list">动态绑定class可使用对象、数组绑定</li> <li class="d-list">动态绑定style可使用对象、数组绑定</li><h3>1.9 计算属性</h3><h4>1.9.1 计算属性的定义：</h4><h5>把数据进行一些转化后再显示，或者把多个数据结合起来进行显示</h5><h4>1.9.2 计算属性的案例：</h4><h5>案例一：firstName+lastName</h5><h5>案例二：books->price</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;计算属性复杂操作&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h2&gt;总价格：&lt;&#x2F;h2&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            books: [                {id: 110, name: &#39;Vue框架&#39;, price: 120},                {id: 111, name: &#39;一行代码&#39;, price: 69},                {id: 112, name: &#39;操作系统&#39;, price: 100},                {id: 113, name: &#39;代码大全&#39;, price: 70}            ]        },        &#x2F;&#x2F;computed计算属性        computed: {            totalPrice: function () {                let result &#x3D; 0                for (let i &#x3D; 0; i &lt; this.books.length; i++) {                    result +&#x3D; this.books[i].price                }                return result            }        },        methods: {}    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h5>计算属性完整写法：</h5><pre><code>&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            firstName: &#39;jerry&#39;,            lastName: &#39;tom&#39;        },        &#x2F;&#x2F;computed计算属性        &#x2F;&#x2F; 属性一般没有set方法，只读属性        computed: {            fullName: {                set: function (newValue) {                    &#x2F;&#x2F; 截取拿到结果的字符串并赋值                    const name &#x3D; newValue.split(&#39; &#39;)                    this.firstName &#x3D; name[0]                    this.lastName &#x3D; name[1]                },                get: function () {                    return this.firstName+&#39; &#39;+this.lastName                }            }        },        methods: {}    })&lt;&#x2F;script&gt;</code></pre><h4>1.9.3 计算属性的缓存：</h4><h5>计算属性性能比方法更高，因为计算属性有缓存，执行时只调用一次，而方法用几次调用几次</h5><h3>1.10 事件监听</h3><h4>1.10.1 v-on</h4><h5>定义：绑定事件监听器，语法糖为'@监听事件'</h5><h4>1.10.2 v-on参数问题</h4><li>情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。</li><li>但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去</li><li>情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。</li><h4>1.10.3 v-on修饰符</h4><li>.stop:阻止冒泡</li><li>.prevent:阻止默认事件，如自动提交</li><li>.{keyCode | keyAlias}:监听某个键盘按键的点击，如：‘input type="text" v-on:keyup.enter="keyUp"（点击enter键，松开时触发）’</li><li>.native:监听组件根元素的原生事件。</li><li>.once:只触发一次回调。</li><h4>1.10.4 v-if和v-show区别</h4><h5>v-if当条件为false时，压根不会有对应的元素在DOM中。</h5><h5>v-show当条件为false时，仅仅是将元素的display属性设置为none而已。</h5><h5>当需要在显示与隐藏之间切片很频繁时，使用v-show</h5><h5>当只有一次切换时，通过使用v-if</h5><h4>1.10.5 遍历循环</h4>使用v-for时最好加上key，为了更好的复用<h5>1.10.5.1 遍历数组</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;v-for遍历数组&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--    1.在遍历的过程中，没有使用索引值--&gt;    &lt;ul&gt;        &lt;li v-for&#x3D;&quot;item in names&quot;&gt;&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;    &lt;!--    2.在遍历的过程中，获取索引值--&gt;    &lt;ul&gt;        &lt;li v-for&#x3D;&quot;(item,index) in names&quot;&gt;NaN.&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            names: [&#39;why&#39;, &#39;Mois&#39;, &#39;Tom&#39;, &#39;Jerry&#39;]        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h5>1.10.5.2 遍历对象</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;v-for遍历对象&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--    1.在遍历的过程中，如果只是获取一个值，那么获取的是value--&gt;    &lt;ul&gt;        &lt;li v-for&#x3D;&quot;item in info&quot;&gt;&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;    &lt;!--    2.获取key和value （value，key）--&gt;    &lt;ul&gt;        &lt;li v-for&#x3D;&quot;(item,key) in info&quot;&gt;:&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&lt;!--    3.获取key、value和index--&gt;    &lt;ul&gt;        &lt;li v-for&#x3D;&quot;(item,key,index) in info&quot;&gt;:-&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            info: {                name: &#39;Mois&#39;,                age: 20,                height: 1.88            }        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h5>1.10.5.3 v-for中最好加入key，但key不能是index（index会有变化）</h5><img src="/img/v-forKey.png"><h4>1.10.6 响应方法</h4>观察数组编译的方法，使用它们改变数组也会触发视图的更新。<li>push():在数组后面添加元素，可添加多个</li><li>pop()：删除最后一个元素</li><li>shift()：删除第一个元素</li><li>unshift()：在数组最前面添加元素，可添加多个</li><li>splice():删除元素、插入元素、替换元素</li>               删除元素,splice(开始位置,删除几个元素),<br>               删除元素splice(开始位置),删除除开始位置后的元素<br>               替换元素，splice(start，替换几个元素，‘替换的元素’，‘替换的元素’)<br>               插入元素,splice(开始元素,0，‘插入的元素’，‘插入的元素’)<br><li>sort()：排序</li><li>reverse()：反转</li><li>set():添加元素，set(添加位置，添加变量名字，添加变量内容)</li><h3>1.11 书籍购物车的案例</h3><h5>index.html</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;style.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;div v-if&#x3D;&quot;books.length&quot;&gt;        &lt;table&gt;            &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;&lt;&#x2F;th&gt;                &lt;th&gt;书籍名称&lt;&#x2F;th&gt;                &lt;th&gt;出版日期&lt;&#x2F;th&gt;                &lt;th&gt;价格&lt;&#x2F;th&gt;                &lt;th&gt;购买数量&lt;&#x2F;th&gt;                &lt;th&gt;操作&lt;&#x2F;th&gt;            &lt;&#x2F;tr&gt;            &lt;&#x2F;thead&gt;            &lt;tbody&gt;            &lt;tr v-for&#x3D;&quot;(book,index) in books&quot;&gt;                &lt;td&gt;book.id&lt;&#x2F;td&gt;                &lt;td&gt;book.name&lt;&#x2F;td&gt;                &lt;td&gt;book.data&lt;&#x2F;td&gt;                &lt;td&gt;book.price|showPrice&lt;&#x2F;td&gt;                &lt;td&gt;                    &lt;button @click&#x3D;&quot;decrement(index)&quot; v-bind:disabled&#x3D;&quot;book.count&lt;&#x3D;1&quot;&gt;-&lt;&#x2F;button&gt;                    &lt;button @click&#x3D;&quot;increment(index)&quot;&gt;+&lt;&#x2F;button&gt;                &lt;&#x2F;td&gt;                &lt;td&gt;                    &lt;button @click&#x3D;&quot;removeHandler(index)&quot;&gt;移除&lt;&#x2F;button&gt;                &lt;&#x2F;td&gt;            &lt;&#x2F;tr&gt;            &lt;&#x2F;tbody&gt;        &lt;&#x2F;table&gt;        &lt;h2&gt;总价格：totalPrice|showPrice&lt;&#x2F;h2&gt;    &lt;&#x2F;div&gt;    &lt;div v-else&gt;        &lt;h2&gt;购物车为空&lt;&#x2F;h2&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;main.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><br><h5>main.js</h5><pre><code>const app &#x3D; new Vue({    el: &#39;#app&#39;,    data: {        books: [            {                id: 1,                name: &#39;《算法导论》&#39;,                data: &#39;2019-03-12&#39;,                price: 89.00,                count: 1            },            {                id: 2,                name: &#39;《UNIX编程艺术》&#39;,                data: &#39;2018-07-13&#39;,                price: 49.00,                count: 5            },            {                id: 3,                name: &#39;《编程珠玑》&#39;,                data: &#39;2020-01-12&#39;,                price: 85.00,                count: 11            },            {                id: 4,                name: &#39;《代码大全》&#39;,                data: &#39;2020-03-22&#39;,                price: 109.00,                count: 2            },        ]    },    methods: {        &#x2F;&#x2F;价格格式化        getFinalPrice(price) {            return &#39;¥&#39; + price.toFixed(2)        },        increment(index) {            this.books[index].count++        },        decrement(index) {            this.books[index].count--        },        removeHandler(index) {            this.books.splice(index, 1)        }    },    &#x2F;&#x2F; 计算属性    computed: {        totalPrice() {            let totalPrice &#x3D; 0            &#x2F;&#x2F;1.普通for循环            for (let i &#x3D; 0; i &lt; this.books.length; i++) {                totalPrice +&#x3D; this.books[i].price * this.books[i].count            }            return totalPrice            &#x2F;&#x2F; 2.for(let i in this.books)            &#x2F;&#x2F;3.for(let i in&#x2F;of this.books)        }    },    &#x2F;&#x2F;过滤器    filters: {        showPrice(price) {            return &#39;¥&#39; + price.toFixed(2)        }    }})</code></pre><br><h5>style.css</h5><pre><code>table {    border: 1px solid #e9e9e9;    border-collapse: collapse;    border-spacing: 0;}th, td {    padding: 8px 16px;    border: 1px solid #e9e9e9;    text-align: left;}th {    background-color: #f7f7f7;    color: #5c6b77;    font-weight: 600;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客</title>
      <link href="/2020/05/11/my-new-post/"/>
      <url>/2020/05/11/my-new-post/</url>
      
        <content type="html"><![CDATA[<p>这是我第二篇博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/11/hello-world/"/>
      <url>/2020/05/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

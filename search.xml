<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue学习（三）</title>
      <link href="/2020/07/09/vue-xue-xi-san/"/>
      <url>/2020/07/09/vue-xue-xi-san/</url>
      
        <content type="html"><![CDATA[<h3>一、 项目开发的步骤</h3><li style="font-size: large">1.1 划分目录结构</li>1.1.1 assets文件夹：放入类似css、img文件夹<br>1.1.2 common文件夹：项目的公共数据，比如公共变量、方法<br>1.1.3 components文件夹：项目的组件，一般里面又分为两个文件夹，common（其他项目也可以用的组件）、content（只有此项目用的组件）<br>1.1.4 network文件夹：网络目录<br>1.1.5 router文件夹：路由目录<br>1.1.6 store文件夹：仓库目录<br>1.1.6 views文件夹：大的视图块<br><li style="font-size: large">1.2 引用css文件</li><br><li style="font-size: large">1.3 设置别名</li><li>在文件中创建vue.config.js文件，router和store可以不设置别名</li><li>设置.editorconfig文件</li><br><li style="font-size: large">1.4 项目的模块划分：路由映射关系</li>]]></content>
      
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习（二）</title>
      <link href="/2020/06/28/vue-xue-xi-er/"/>
      <url>/2020/06/28/vue-xue-xi-er/</url>
      
        <content type="html"><![CDATA[<h3>1.1 过滤器：</h3><h4>在js中使用filters设置，运用‘item|过滤器’</h4><h3>1.2 v-model：</h3><h4>v-model指令可以实现表单元素和数据的双向绑定，如：动态得到输入框(input、textarea)的值</h4><h4>v-model其实是一个语法糖，它的背后本质上是包含两个操作：</h4>    <li>1.v-bind绑定一个value属性，得到值</li>    <li>2.v-on指令给当前元素绑定input事件，监听值的改变</li><pre><code>&lt;input type&#x3D;&quot;text&quot; v-bind:value&#x3D;&quot;message&quot; v-on:input&#x3D;&quot;message &#x3D; $event.target.value&quot;&gt;</code></pre><h4>1.2.1 v-model案例</h4>单选框<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;v-model结合radio&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--    使用name使单选框只能选一个--&gt;    &lt;label for&#x3D;&quot;male&quot;&gt;        &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;male&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;男&quot; v-model&#x3D;&quot;sex&quot;&gt;男    &lt;&#x2F;label&gt;    &lt;label for&#x3D;&quot;female&quot;&gt;        &lt;input type&#x3D;&quot;radio&quot; id&#x3D;&quot;female&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;女&quot; v-model&#x3D;&quot;sex&quot;&gt;女    &lt;&#x2F;label&gt;    &lt;br&gt;    &lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;,            sex: &#39;男&#39;        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><br>复选框<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;v-model结合checkbox&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--  checkbox单选框  --&gt;    &lt;!--    &lt;label for&#x3D;&quot;license&quot;&gt;--&gt;    &lt;!--        &lt;input type&#x3D;&quot;checkbox&quot; id&#x3D;&quot;license&quot; v-model&#x3D;&quot;isAgree&quot;&gt;同意协议--&gt;    &lt;!--    &lt;&#x2F;label&gt;--&gt;    &lt;!--    &lt;h2&gt;&lt;&#x2F;h2&gt;--&gt;    &lt;!--    &lt;button :disabled&#x3D;&quot;!isAgree&quot;&gt;下一步&lt;&#x2F;button&gt;--&gt;    &lt;!--    &lt;br&gt;--&gt;    &lt;!--    --&gt;    &lt;!--  checkbox多选框  --&gt;    &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;篮球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;篮球    &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;足球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;足球    &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;乒乓球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;乒乓球    &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;羽毛球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;羽毛球    &lt;input type&#x3D;&quot;checkbox&quot; value&#x3D;&quot;网球&quot; v-model&#x3D;&quot;hobbies&quot;&gt;网球    &lt;br&gt;    &lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;,            isAgree: false,&#x2F;&#x2F;单选框            hobbies: []&#x2F;&#x2F;多选框        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4>1.2.2 v-model修饰符</h4><h5>lazy修饰符：</h5>默认情况下，v-model默认是在input事件中同步输入框的数据的。也就是说，一旦有数据发生改变对应的data中的数据就会自动发生改变。<br>lazy修饰符可以让数据在失去焦点或者回车时才会更新<h5>number修饰符：</h5>默认情况下，在输入框中无论我们输入的是字母还是数字，都会被当做字符串类型进行处理。但是如果我们希望处理的是数字类型，那么最好直接将内容当做数字处理。<br>number修饰符可以让在输入框中输入的内容自动转成数字类型<h5>trim修饰符：</h5>如果输入的内容首尾有很多空格，通常我们希望将其去除<br>trim修饰符可以过滤内容左右两边的空格<h3>1.3 组件化</h3><h4>1.3.1 概念</h4>如果我们将一个页面中所有的处理逻辑全部放在一起，处理起来就会变得非常复杂，而且不利于后续的管理以及扩展。<br>但如果，我们将一个页面拆分成一个个小的功能块，每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就变得非常容易了。<h4>1.3.2 注册组件的基本步骤</h4><li>创建组件构造器(调用Vue.extend()方法)</li><li>注册组件(调用Vue.component()方法)</li><li>使用组件(在Vue实例的作用范围内使用)</li>1.Vue.extend()：调用Vue.extend()创建的是一个组件构造器。 <br>通常在创建组件构造器时，传入<b>template</b>代表我们自定义组件的模板。该模板就是在使用到组件的地方，要显示的HTML代码。<br>2.Vue.component()：调用Vue.component()是将刚才的组件构造器注册为一个组件，并且给它起一个组件的标签名称。所以需要传递两个参数：1、注册组件的标签名 2、组件构造器<br>3.组件必须挂载在某个Vue实例下，否则它不会生效。<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;vue组件化基本使用&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--3.使用组件--&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;cpn&gt;&lt;&#x2F;cpn&gt;    &lt;cpn&gt;&lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;ES6    &#x2F;&#x2F;1.创建组件构造器对象    const cpnC &#x3D; Vue.extend({        template: &#96;&lt;div&gt;    &lt;h2&gt;我是标题&lt;&#x2F;h2&gt;    &lt;p&gt;我是内容1&lt;&#x2F;p&gt;    &lt;p&gt;我是内容2&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&#96;    })    &#x2F;&#x2F;2.注册组件    &#x2F;&#x2F; Vue.component(&#39;组件标签名&#39;,&#39;创建的组件名字&#39;)    Vue.component(&#39;cpn&#39;, cpnC)    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4>1.3.3 父组件和子组件</h4><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;父组件与子组件&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;cpn2&gt;&lt;&#x2F;cpn2&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F; 1.创建第一个组件（子组件）    const cpnC1 &#x3D; Vue.extend({        template: &#96;        &lt;div&gt;        &lt;h2&gt;我是标题啊1&lt;&#x2F;h2&gt;        &lt;p&gt;我是内容！！！！&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&#96;    })    &#x2F;&#x2F; 2.创建第二个组件（父组件）    const cpnC2 &#x3D; Vue.extend({        template: &#96;        &lt;div&gt;        &lt;h2&gt;我是标题啊2&lt;&#x2F;h2&gt;        &lt;p&gt;我是内容！！！！2222&lt;&#x2F;p&gt;        &lt;cpn1&gt;&lt;&#x2F;cpn1&gt;&lt;&#x2F;div&gt;&#96;,        components:{            cpn1:cpnC1        }    })    &#x2F;&#x2F;root组件    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;        },        components:{            cpn2:cpnC2        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4>1.3.4 组件的语法糖和模板分离</h4>1.全局组件注册的语法糖Vue.component('组件签名',{组件内容})<br>2.局部组件注册的语法糖component:{'组件签名',{组件内容}}<br>模板分离两种方法：<br>1.使用scrpit,类型text/x-template标签<br>2.使用template标签<h4>1.3.5 组件数据的存放</h4>组件不能直接访问Vue实例的数据（data）<h5>使用方法：在组件注册时定义数据，并有返回值</h5><pre><code>Vue.component(&#39;cpn&#39;, {    template: &#39;#cpn&#39;,    data(){        return {            title:&#39;hahhahahahhhh&#39;        }    }})</code></pre><h4>1.3.6 父子组件的通信</h4><li>通过props向子组件传递数据</li><li>通过事件($emit Events)向父组件发送消息</li><h5> 1.3.6.1 父向子传数据（props）</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;父组件向子组件传递数据&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--    注意：要使用v-bind绑定数据--&gt;    &lt;cpn :vmovies&#x3D;&quot;movies&quot; :cm&#x3D;&quot;message&quot;&gt;&lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt;    &lt;div&gt;        &lt;ul&gt;            &lt;li v-for&#x3D;&quot;item in vmovies&quot;&gt;&lt;&#x2F;li&gt;        &lt;&#x2F;ul&gt;            &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F; 父传子，props    const cpn &#x3D; {        template: &#39;#cpn&#39;,        &#x2F;&#x2F; 通过数组        &#x2F;&#x2F; props: [&#39;vmovies&#39;, &#39;cm&#39;],        &#x2F;&#x2F; 通过对象        props: {            &#x2F;&#x2F; 1.类型限制            &#x2F;&#x2F; vmoives: Array,            &#x2F;&#x2F; cm:String                        &#x2F;&#x2F; 2.提供一些默认值，required设置必传值            cm:{                type:String,                default:&#39;aaaaaaaaa&#39;,                required:true            },            &#x2F;&#x2F; 类型是对象或者数组时，默认值是一个函数            vmovies:{                type:Array,                default(){                    return []                }            }        },        data() {            return {}        },        methods: {}    }    const app &#x3D; new Vue({        el: &#39;#app&#39;,        &#x2F;&#x2F; 父组件的数据        data: {            message: &#39;你好啊&#39;,            movies: [&#39;海王&#39;, &#39;海贼王&#39;, &#39;海绵宝宝&#39;]        },        components: {            &#x2F;&#x2F; 增强写法，本是&#39;cpn&#39;:cpn            cpn        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h5> 1.3.6.2 子向父传数据（$emit()发射事件）</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;子传父&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;!--父组件模板--&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--    监听子组件发送的事件--&gt;    &lt;cpn @itemclick&#x3D;&quot;cpnClick&quot;&gt;&lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt;&lt;!--子组件模板--&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt;    &lt;div&gt;        &lt;button v-for&#x3D;&quot;item in categories&quot; @click&#x3D;&quot;btnClick(item)&quot;&gt;&lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;子组件    const cpn &#x3D; {        template: &#39;#cpn&#39;,        data() {            return {                categories: [                    {id: &#39;aaa&#39;, name: &#39;热门推荐&#39;},                    {id: &#39;bbb&#39;, name: &#39;手机数码&#39;},                    {id: &#39;ccc&#39;, name: &#39;家用电器&#39;},                    {id: &#39;ddd&#39;, name: &#39;电脑办公&#39;},                ]            }        },        methods: {            btnClick(item) {                &#x2F;&#x2F; 发射事件，&#39;事件名称&#39;,值                this.$emit(&#39;itemclick&#39;, item)            }        }    }    &#x2F;&#x2F;父组件    const app &#x3D; new Vue({        el: &#39;#app&#39;,        &#x2F;&#x2F; 父组件的数据        data: {            message: &#39;你好啊&#39;,            movies: [&#39;海王&#39;, &#39;海贼王&#39;, &#39;海绵宝宝&#39;]        },        components: {            &#x2F;&#x2F; 增强写法，本是&#39;cpn&#39;:cpn            cpn        },        methods: {            cpnClick(item) {                console.log(item)            }        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h5> 1.3.6.3 父子间相互传递数据</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;父子组件通信&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;cpn :number1&#x3D;&quot;num1&quot;         :number2&#x3D;&quot;num2&quot;         @num1change&#x3D;&quot;num1change&quot;         @num2change&#x3D;&quot;num2change&quot;&gt;&lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt;    &lt;div&gt;        &lt;h2&gt;props:&lt;&#x2F;h2&gt;        &lt;h2&gt;data:&lt;&#x2F;h2&gt;        &lt;!--        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;dnumber1&quot;&gt;--&gt;        &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;dnumber1&quot; @input&#x3D;&quot;num1Input&quot;&gt;        &lt;h2&gt;props:&lt;&#x2F;h2&gt;        &lt;h2&gt;data:&lt;&#x2F;h2&gt;        &lt;!--        &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;dnumber2&quot;&gt;--&gt;        &lt;input type&#x3D;&quot;text&quot; :value&#x3D;&quot;dnumber2&quot; @input&#x3D;&quot;num2Input&quot;&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            num1: 1,            num2: 0        },        methods: {            num1change(value) {                this.num1 &#x3D; parseFloat(value)            },            num2change(value) {                this.num2 &#x3D; parseFloat(value)            }        },        components: {            cpn: {                template: &#39;#cpn&#39;,                props: {                    number1: Number,                    number2: Number                },                data() {                    return {                        dnumber1: this.number1,                        dnumber2: this.number2                    }                },                methods: {                    num1Input(event) {                        &#x2F;&#x2F; 1.将input中的value复制到dnumber                        this.dnumber1 &#x3D; event.target.value;                        &#x2F;&#x2F; 2.为了让父组件可以修改值，发出一个事件                        this.$emit(&#39;num1change&#39;, this.dnumber1)                        &#x2F;&#x2F; 3.同时修饰dnumber2的值                        this.dnumber2 &#x3D; this.dnumber1 * 100;                        this.$emit(&#39;num2change&#39;,this.dnumber2)                    },                    num2Input(event) {                        this.dnumber2 &#x3D; event.target.value                        this.$emit(&#39;num2change&#39;, this.dnumber2)                        this.dnumber1 &#x3D; this.dnumber2 &#x2F; 100;                        this.$emit(&#39;num1change&#39;,this.dnumber1)                    }                }            }        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4> 1.3.7 父子组件的访问方式</h4><h5>有时候我们需要父组件直接访问子组件，子组件直接访问父组件，或者是子组件访问跟组件。<br>    <br><li>父组件访问子组件：使用$children或$refs</li>    <br><li>子组件访问父组件：使用$parent</li></h5><br><h5>1.3.7.1 父组件访问子组件 $children和$refs（推荐）的使用</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;父访问子-children-refs&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;cpn&gt;&lt;&#x2F;cpn&gt;    &lt;cpn&gt;&lt;&#x2F;cpn&gt;    &lt;cpn ref&#x3D;&quot;aaa&quot;&gt;&lt;&#x2F;cpn&gt;    &lt;button @click&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt;    &lt;div&gt;我是子组件&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;        },        methods: {            btnClick() {                &#x2F;&#x2F; 1.$children                &#x2F;&#x2F; console.log(this.$children);                &#x2F;&#x2F; this.$children[0].showMessage()                &#x2F;&#x2F; console.log(this.$children[0].name);                &#x2F;&#x2F; 2.$refs（推荐）-&gt;对象类型，默认是空对象，设置ref                console.log(this.$refs.aaa.name);            }        },        components: {            cpn: {                template: &#39;#cpn&#39;,                data() {                    return {                        name: &#39;我是子组件的name&#39;                    }                },                methods: {                    showMessage() {                        console.log(&#39;showMessage&#39;)                    }                }            }        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h5>1.3.7.2 子组件访问父组件 $parent和$root的使用</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;组件访问-子组件访问父组件&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;cpn&gt;&lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt;    &lt;div&gt;        我是cpn组件        &lt;ccpn&gt;&lt;&#x2F;ccpn&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;template id&#x3D;&quot;ccpn&quot;&gt;    &lt;div&gt;        &lt;h2&gt;我是子组件&lt;&#x2F;h2&gt;        &lt;button @click&#x3D;&quot;btnClick&quot;&gt;按钮&lt;&#x2F;button&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;        },        components: {            cpn: {                template: &#39;#cpn&#39;,                components: {                    ccpn: {                        template: &#39;#ccpn&#39;,                        methods: {                            btnClick() {                                &#x2F;&#x2F;1.访问父组件$parent                                console.log(this.$parent)                                console.log(this.$parent.name)                                &#x2F;&#x2F;2.访问root组件                                console.log(this.$root)                                console.log(this.$root.message)                            }                        }                    }                }            },        },    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4>1.3.8 插槽slot</h4><h5>多处使用一个模板，但功能不同，可以使用插槽定义（占位），后在具体应用中设置不同的功能</h5><h5>插槽中可以定义默认值，之后使用重新定义可替换默认的功能</h5><h5>具名插槽：给插槽定义name，使用是在标签内说明slot='name名字'，可以分辨不同的slot</h5><br>作用域插槽<pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;作用域插槽&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;cpn&gt;&lt;&#x2F;cpn&gt;    &lt;cpn&gt;        &lt;!--目的：获取子组件的pLanguage--&gt;        &lt;template slot-scope&#x3D;&quot;slot&quot;&gt;            &lt;!--&lt;span v-for&#x3D;&quot;item in slot.data&quot;&gt; - &lt;&#x2F;span&gt;--&gt;            &lt;!--使用join连接字符串--&gt;            &lt;span&gt;slot.data.join(&#39; - &#39;)&lt;&#x2F;span&gt;        &lt;&#x2F;template&gt;    &lt;&#x2F;cpn&gt;    &lt;cpn&gt;        &lt;!-- 目的：得到子组件的pLanguage--&gt;        &lt;template slot-scope&#x3D;&quot;slot&quot;&gt;            &lt;span v-for&#x3D;&quot;item in slot.data&quot;&gt; --&#x3D;&lt;&#x2F;span&gt;        &lt;&#x2F;template&gt;    &lt;&#x2F;cpn&gt;&lt;&#x2F;div&gt;&lt;template id&#x3D;&quot;cpn&quot;&gt;    &lt;div&gt;        &lt;!--data可改为自定义名字，获取组件中pLanguage数据--&gt;        &lt;slot :data&#x3D;&quot;pLanguage&quot;&gt;            &lt;ul&gt;                &lt;li v-for&#x3D;&quot;item in pLanguage&quot;&gt;&lt;&#x2F;li&gt;            &lt;&#x2F;ul&gt;        &lt;&#x2F;slot&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            message: &#39;你好啊&#39;        },        components: {            cpn: {                template: &#39;#cpn&#39;,                data() {                    return {                        pLanguage: [&#39;JavaScrpit&#39;, &#39;C++&#39;, &#39;Python&#39;, &#39;C#&#39;, &#39;Go&#39;]                    }                }            }        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h4>1.3.9 模块化开发</h4><h5>常见的模块化规范：CommonJS,AMD,CMD,ES6的Modules</h5><h4>1.3.10 Webpack</h4><h5>webpack是一个现代的JavaScript应用的静态模块打包工具。</h5><h5>插件：对某个现有的框架进行扩展</h5><h3>1.4 Vue cli（脚手架）</h3>使用vue init webpack my-project(vue cli2)或者vue create my-project(vue cli3)初始化项目<h4>Vue cli2</h4><img src="/img/vuecli01.png"><h4>Vue cli3</4><img src="/img/vuecli02.png"><h4>Runtime-Compiler和Runtime-only的区别</h4><br>两者在main.js中不同<li>如果在之后的开发中，你依然使用template，就需要选择Runtime-Compiler</li><li>如果你之后的开发中，使用的是.vue文件夹开发，那么可以选择Runtime-only</li><br><b>runtimecompiler：</b><br>template->ast->render->vdom->UI<b><br>runtimeonly：（性能更高，代码量更少）</b><br>render->vdom->UI<h3>1.5 vue-router（路由）</h3><h4>后端路由：后端处理URL和页面之间的映射关系</h4><h4>前后端分离：有ajax，前端url发送到静态资源服务器</h4><h4>前端路由：前端管理映射关系，抽取一部分js代码处理</h4><h4>1.5.1 改变URL，但是页面不进行整体的刷新的实现</h4><li>url的hash：location.hash='/foo'，直接改变href</li><li>html5的history模式：</li><li>(1)history.pushState({},'','/foo')，可以返回</li><li>(2)history.replaceState({},'','/foo')，不可以返回</li><li>(3)history.go(-1)</li><li>(4)history.back() 等价于 history.go(-1),history.forward() 则等价于 history.go(1)</li><h4>1.5.2 动态路由：</h4><li>在配置路由和组件映射关系式，path中，路径后加上'/:变量名'</li><li>在app.vue中，绑定事件，在路径后面加上变量名，如:v-bind:to="'/user/'+userId"</li><li>若要在页面显示变量，可以使用$route.params.变量名，获得当前活跃的路由，注意是route（路由），不是router（路由器）</li><h4>1.5.3 路由懒加载</h4><h5>懒加载：需要用到时才进行加载</h5><h5>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块,只有在这个路由被访问到的时候, 才加载对应的组件</h5><h5>出去三个对应的js文件，有几个组件就打包成对应的js代码块</h5><li>方式一：结合Vue的异步组件和Webpack的代码分析.</li>const Home = resolve => { require.ensure(['../components/Home.vue'], () => { resolve(require('../components/Home.vue')) })};<li>方式二: AMD写法:</li>const About = resolve => require(['../components/About.vue'], resolve);<li>方式三: 在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割.</li>const Home = () => import('../components/Home.vue')<h4>1.5.4 $route和$router的区别</h4>$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法$route为当前router跳转对象里面可以获取name、path、query、params等<h4>1.5.5 导航守卫</h4> vue-router提供的导航守卫主要用来监听监听路由的进入和离开的.vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发.<h4>1.5.6 keep-alive</h4> 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<h5>属性：</h5><li>include - 字符串或正则表达，只有匹配的组件会被缓存</li><li>exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</li><h3>1.6 Promise</h3><h4>1.6.1 什么情况会用到promise？</h4>一般情况下是有异步操作时，使用promise对这个异步操作进行封装<pre><code>&#x2F;&#x2F; 什么情况会用到promise?    &#x2F;&#x2F; 一般情况下是有异步操作时，使用promise对这个异步操作进行封装    &#x2F;&#x2F; new-&gt;执行构造函数（1 保存了一些状态信息 2.执行传入函数）    &#x2F;&#x2F; 在执行传入的回调函数时，会传入两个参数，resolve，reject本身也是函数    new Promise((resolve, reject) &#x3D;&gt; {        setTimeout(() &#x3D;&gt; {            &#x2F;&#x2F; 成功时调用resolve            &#x2F;&#x2F; resolve(&#39;Hello world&#39;)            &#x2F;&#x2F; 失败时调用reject            reject(&#39;error message&#39;)        }, 1000)    }).then((data) &#x3D;&gt; {        console.log(data);        console.log(data);        console.log(data);        console.log(data);    }).catch((err) &#x3D;&gt; {        console.log(err);    })</code></pre><h4>1.6.2 promise的三种状态</h4><li>(1) pending: 等待状态，比如正在进行网络请求，或者定时器没有到时间。</li><li>(2) fulfill: 满足状态，当我们主动回调了resolve时，就处于该状态，并且会回调.then()</li><li>(3) reject: 拒绝状态，当我们主动回调了reject时，就处于该状态，并且会回调.catch()</li><p>最简化代码</p><pre><code>&#x2F;&#x2F; 最简化    new Promise((resolve, reject) &#x3D;&gt; {        setTimeout(() &#x3D;&gt; {            resolve(&#39;aaa&#39;)        }, 1000)    }).then(res &#x3D;&gt; {        &#x2F;&#x2F; 自己处理10行代码        console.log(res, &#39;第一层代码&#39;);&#x2F;&#x2F; 2.对结果处理        return res + &#39;111&#39;    }).then(res &#x3D;&gt; {        console.log(res, &#39;第二层&#39;);        return Promise.reject(&#39;error message&#39;)    }).then(res &#x3D;&gt; {        console.log(res, &#39;第三层代码&#39;);    })</code></pre><h3>1.7 Vuex</h3><h5>vuex是一个专门为vue.js应用程序开发的状态管理模式</h5><h4>1.7.1 管理什么状态？</h4><li>用户的登录状态、用户名称、头像、地理位置信息等等。</li><li>商品的收藏、购物车中的物品等等。</li>    这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的。<h4>1.7.2 Vuex几个核心的概念</h4><li>State</li><li>Getters</li><li>Mutation</li><li>Action</li><li>Module</li><h5>1.7.2.1 State单一状态树</h5>单一数据源，管理应用层的全部状态，让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护。<h5>1.7.2.2 Getters</h5>类似于计算属性<h6>index.js</h6><pre><code>import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)const store &#x3D; new Vuex.Store({  state: {    counter: 1000,    students: [      {id: 110, name: &#39;why&#39;, age: 23},      {id: 112, name: &#39;Mois&#39;, age: 20},      {id: 113, name: &#39;dimmo&#39;, age: 10},      {id: 114, name: &#39;Molly&#39;, age: 19}    ]  },  getters: {    powerCounter(state) {      return state.counter * state.counter    },    more20stu(state) {      return state.students.filter(s &#x3D;&gt; s.age &gt; 10)    },    more20stuLength(state, getters) {      return getters.more20stu.length    },    moreAgestu(state) {      return function (age) {        return state.students.filter(s &#x3D;&gt; s.age &gt; age)      }    }  },  modules: {}})export default store</code></pre><h6>App.vue</h6><pre><code>&lt;template&gt;  &lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h2&gt;---------App内容:getters相关信息-------------&lt;&#x2F;h2&gt;    &lt;h2&gt;$store.getters.powerCounter&lt;&#x2F;h2&gt;    &lt;h2&gt;$store.getters.more20stu&lt;&#x2F;h2&gt;    &lt;h2&gt;$store.getters.more20stuLength&lt;&#x2F;h2&gt;    &lt;h2&gt;$store.getters.moreAgestu(9)&lt;&#x2F;h2&gt;&lt;!--    &lt;h2&gt;$store.getters.more20stu.length&lt;&#x2F;h2&gt;--&gt;    &lt;h2&gt;---------HelloVuex内容-------------&lt;&#x2F;h2&gt;    &lt;hello-vuex&#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  import HelloVuex from &quot;.&#x2F;components&#x2F;HelloVuex&quot;;    export default {        name: &#39;App&#39;,        components:{            HelloVuex        },        data() {            return {                message: &#39;我是app组件&#39;,                counter:0            }        }    }&lt;&#x2F;script&gt;</code></pre><h5>1.7.2.3 Mutation</h5><h6>Vuex的store状态的更新唯一方式：提交Mutation</h6><h6>Mutation主要包括两部分：</h6><li>字符串的事件类型（type）</li><li>一个回调函数（handler）,该回调函数的第一个参数就是state。</li><h6>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新.</h6>这就要求我们必须遵守一些Vuex对应的规则:<li>提前在store中初始化好所需的属性.</li><li>当给state中的对象添加新属性时, 使用下面的方式:</li>方式一: 使用Vue.set(obj, 'newProp', 123)<br>方式二: 用心对象给旧对象重新赋值<br>删除使用Vue.deleteindex.js<pre><code>import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;Vue.use(Vuex)const store &#x3D; new Vuex.Store({  state: {    counter: 1000,    students: [      {id: 110, name: &#39;why&#39;, age: 23},      {id: 112, name: &#39;Mois&#39;, age: 20},      {id: 113, name: &#39;dimmo&#39;, age: 10},      {id: 114, name: &#39;Molly&#39;, age: 19}    ]  },  &#x2F;&#x2F; 同步操作  mutations: {    increment(state) {      state.counter++    },    decrement(state) {      state.counter--    },    incrementCount(state, payload) {      &#x2F;&#x2F; state.counter +&#x3D; payload      console.log(&quot;payloas&quot;,payload);      console.log(&quot;count:&quot;,payload.count);      state.counter +&#x3D; payload.count    },    addStudent(state,stu){      state.students.push(stu)    }  }  },  modules: {}})export default store</code></pre><p>app.vue</p><pre><code>&lt;template&gt;  &lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h2&gt;---------App内容-------------&lt;&#x2F;h2&gt;    &lt;h2&gt;&lt;&#x2F;h2&gt;    &lt;button @click&#x3D;&quot;addition&quot;&gt;+&lt;&#x2F;button&gt;    &lt;button @click&#x3D;&quot;subtraction&quot;&gt;-&lt;&#x2F;button&gt;    &lt;button @click&#x3D;&quot;addCount(5)&quot;&gt;+5&lt;&#x2F;button&gt;    &lt;button @click&#x3D;&quot;addCount(10)&quot;&gt;+10&lt;&#x2F;button&gt;    &lt;button @click&#x3D;&quot;addStudent&quot;&gt;添加学生&lt;&#x2F;button&gt;&lt;!--    &lt;h2&gt;&lt;&#x2F;h2&gt;--&gt;    &lt;h2&gt;---------HelloVuex内容-------------&lt;&#x2F;h2&gt;    &lt;hello-vuex&#x2F;&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;  import HelloVuex from &quot;.&#x2F;components&#x2F;HelloVuex&quot;;    export default {        name: &#39;App&#39;,        components:{            HelloVuex        },        data() {            return {                message: &#39;我是app组件&#39;,                counter:0            }        },        methods:{            addition(){                &#x2F;&#x2F; 括号内为方法名                this.$store.commit(&#39;increment&#39;)            },            subtraction(){                this.$store.commit(&#39;decrement&#39;)            },            addCount(count){                &#x2F;&#x2F; 1、普通提交风格                &#x2F;&#x2F; this.$store.commit(&#39;incrementCount&#39;,count)                &#x2F;&#x2F; 2.特殊的提交封装                this.$store.commit({                    type:&#39;incrementCount&#39;,                    count                })            },            addStudent(){                const stu &#x3D;{id:114,name:&#39;alan&#39;,age:33}                this.$store.commit(&#39;addStudent&#39;,stu)            }        }    }&lt;&#x2F;script&gt;</code></pre><li>字符串的事件类型（type）</li><li>一个回调函数（handler）,该回调函数的第一个参数就是state。</li><h5>1.7.2.4 Action</h5>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.调用action方法时要用dispatch<pre><code>mutations: {    updateName(state,payload){      state.name&#x3D;payload    }  },  &#x2F;&#x2F; 异步操作  actions: {    aUpdateName(context){      setTimeout(()&#x3D;&gt;{        context.commit(&#39;updateName&#39;,&#39;xixiximois&#39;)      },1000)    }  }    &#x2F;&#x2F;调用  updateName(){                  this.$store.commit(&#39;updateName&#39;,&#39;hahamois&#39;)              },  </code></pre><h5>1.7.2.5 Module</h5>声明一个模块，局部通过context.state暴露，根结点状态为context.rootState<pre><code>const moduleA&#x3D;{  state: {    name:&#39;MMMois&#39;  },  &#x2F;&#x2F; 同步操作  mutations: {    updateName(state,payload){      state.name&#x3D;payload    }  },  &#x2F;&#x2F; 异步操作  actions: {    aUpdateName(context){      setTimeout(()&#x3D;&gt;{        context.commit(&#39;updateName&#39;,&#39;xixiximois&#39;)      },1000)    }  },  &#x2F;&#x2F; 类似计算属性  getters: {    fullname(state){      return state.name+&#39;222222&#39;    },    fullname2(state,getters){      return getters.fullname+&#39;333333333&#39;    },    &#x2F;&#x2F; 拼接主模块的内容rootState    fullname3(state,getters,rootState){      return getters.fullname+&#39;333333333&#39;+rootState.counter    }  },}  </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6语法（来自b站课件）</title>
      <link href="/2020/06/27/es6-yu-fa-lai-zi-b-zhan-ke-jian/"/>
      <url>/2020/06/27/es6-yu-fa-lai-zi-b-zhan-ke-jian/</url>
      
        <content type="html"><![CDATA[<img src="/img/ES601.png"><img src="/img/ES602.png"><img src="/img/ES603.png">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前端基础知识总结</title>
      <link href="/2020/05/12/qian-duan-ji-chu-zhi-shi-zong-jie/"/>
      <url>/2020/05/12/qian-duan-ji-chu-zhi-shi-zong-jie/</url>
      
        <content type="html"><![CDATA[<h4>JavaScript面试题</h4><a>https://segmentfault.com/a/1190000015288700</a>]]></content>
      
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 学习（一）</title>
      <link href="/2020/05/12/vue-xue-xi-yi/"/>
      <url>/2020/05/12/vue-xue-xi-yi/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css"><script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script><style>.d-list{    font-size: 15pt;    display:list-item;    list-style-position: inside;    list-style-type: circle;}</style><h1>一、认识Vuejs</h1><h3>1.1 Vue是一个渐进式的框架。</h3><h4> 1.1.1 渐进式：</h4><div class="d-list">渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验。</div><div class="d-list">或者如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统。</div><div class="d-list">比如Core+Vue-router+Vuex，也可以满足你各种各样的需求。</div><h3>1.2 第一个Vue实例</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;let（变量）&#x2F;const（常量）    &#x2F;&#x2F;编程范式：声明式编程    const app &#x3D; new Vue({        el: &#39;#app&#39;,&#x2F;&#x2F;用于挂载要管理的元素        data: {&#x2F;&#x2F;定义数据            message: &#39;你好！&#39;        }    })    &#x2F;&#x2F;元素js的做法（编程范式：命令式编程）    &#x2F;&#x2F;1.创建div元素，设置id属性    &#x2F;&#x2F;2.定义一个message变量    &#x2F;&#x2F;3.将message变量放在前面的div元素中显示    &#x2F;&#x2F;4.修改message数据，并替换&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3>1.3 第二个Vue实例-列表</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;ul&gt;        &lt;li v-for&#x3D;&quot;item in movies&quot;&gt;&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            messages: &#39;你好啊&#39;,            movies: [&#39;魔界契约&#39;, &#39;海王&#39;, &#39;哪吒&#39;, &#39;盗墓笔记&#39;]        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3>1.4 第三个Vue实例-计数器</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h2&gt;当前计数：&lt;&#x2F;h2&gt;    &lt;!--    v-on监听--&gt;    &lt;!--    &lt;button v-on:click&#x3D;&quot;counter++&quot;&gt;+&lt;&#x2F;button&gt;--&gt;    &lt;!--    &lt;button v-on:click&#x3D;&quot;counter&amp;#45;&amp;#45;&quot;&gt;-&lt;&#x2F;button&gt;--&gt;    &lt;button v-on:click&#x3D;&quot;add&quot;&gt;+&lt;&#x2F;button&gt;    &lt;button @click&#x3D;&quot;sub&quot;&gt;-&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    &#x2F;&#x2F;语法糖：简写 @click是v-on:click的语法糖    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            counter: &#39;0&#39;        },        methods: {            add: function () {                console.log(&#39;add被执行&#39;)                this.counter++            },            sub: function () {                console.log(&#39;sub被执行&#39;)                this.counter--            }        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h3>1.5 MVVM</h3><h4>Model View ViewModel</h4><ul>View层：<li>视图层</li><li>在我们前端开发中，通常就是DOM层。</li><li>主要的作用是给用户展示各种信息。</li></ul><ul>Model层：<li>数据层</li><li>数据可能是我们固定的死数据，更多的是来自我们服务器，从网络上请求下来的数据。</li><li>在我们计数器的案例中，就是后面抽取出来的obj，当然，里面的数据可能没有这么简单。</li></ul><ul>VueModel层：<li>视图模型层</li><li>视图模型层是View和Model沟通的桥梁。</li><li>一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中</li><li>另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。</li></ul><h3>1.6 开发中什么是函数，什么是方法？</h3><li>函数：function，直接在script里面定义 </li><li>方法：method，一般定义在类里面</li><h3>1.7 vue的生命周期</h3>初始化->更新->死亡<img src="/img/pic01.png"><h3>1.8 模板语法</h3><h4>1.8.1 Mustache语法（双括号）:可以使用简单的表达式</h4><h4>1.8.2 v-once:只渲染一次，之后不会随数据更改，并且后面不跟表达式</h4><h4>1.8.3 v-html：设置有标签的超链接</h4><h4>1.8.4 v-text：类似于Mustache语法，但不可拼接，使用较少</h4><h4>1.8.5 v-pre：原封不动的显示标签内的内容，不用解析</h4><h4>1.8.6 v-cloak：在vue解析之前有效，避免显然出未编译的Mustache标签</h4><h4>1.8.7 v-bind：</h4> <li class="d-list">动态绑定链接属性</li> <li class="d-list">语法糖：':'</li> <li class="d-list">动态绑定class可使用对象、数组绑定</li> <li class="d-list">动态绑定style可使用对象、数组绑定</li><h3>1.9 计算属性</h3><h4>1.9.1 计算属性的定义：</h4><h5>把数据进行一些转化后再显示，或者把多个数据结合起来进行显示</h5><h4>1.9.2 计算属性的案例：</h4><h5>案例一：firstName+lastName</h5><h5>案例二：books->price</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;计算属性复杂操作&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;h2&gt;总价格：&lt;&#x2F;h2&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            books: [                {id: 110, name: &#39;Vue框架&#39;, price: 120},                {id: 111, name: &#39;一行代码&#39;, price: 69},                {id: 112, name: &#39;操作系统&#39;, price: 100},                {id: 113, name: &#39;代码大全&#39;, price: 70}            ]        },        &#x2F;&#x2F;computed计算属性        computed: {            totalPrice: function () {                let result &#x3D; 0                for (let i &#x3D; 0; i &lt; this.books.length; i++) {                    result +&#x3D; this.books[i].price                }                return result            }        },        methods: {}    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h5>计算属性完整写法：</h5><pre><code>&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            firstName: &#39;jerry&#39;,            lastName: &#39;tom&#39;        },        &#x2F;&#x2F;computed计算属性        &#x2F;&#x2F; 属性一般没有set方法，只读属性        computed: {            fullName: {                set: function (newValue) {                    &#x2F;&#x2F; 截取拿到结果的字符串并赋值                    const name &#x3D; newValue.split(&#39; &#39;)                    this.firstName &#x3D; name[0]                    this.lastName &#x3D; name[1]                },                get: function () {                    return this.firstName+&#39; &#39;+this.lastName                }            }        },        methods: {}    })&lt;&#x2F;script&gt;</code></pre><h4>1.9.3 计算属性的缓存：</h4><h5>计算属性性能比方法更高，因为计算属性有缓存，执行时只调用一次，而方法用几次调用几次</h5><h3>1.10 事件监听</h3><h4>1.10.1 v-on</h4><h5>定义：绑定事件监听器，语法糖为'@监听事件'</h5><h4>1.10.2 v-on参数问题</h4><li>情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。</li><li>但是注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去</li><li>情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。</li><h4>1.10.3 v-on修饰符</h4><li>.stop:阻止冒泡</li><li>.prevent:阻止默认事件，如自动提交</li><li>.{keyCode | keyAlias}:监听某个键盘按键的点击，如：‘input type="text" v-on:keyup.enter="keyUp"（点击enter键，松开时触发）’</li><li>.native:监听组件根元素的原生事件。</li><li>.once:只触发一次回调。</li><h4>1.10.4 v-if和v-show区别</h4><h5>v-if当条件为false时，压根不会有对应的元素在DOM中。</h5><h5>v-show当条件为false时，仅仅是将元素的display属性设置为none而已。</h5><h5>当需要在显示与隐藏之间切片很频繁时，使用v-show</h5><h5>当只有一次切换时，通过使用v-if</h5><h4>1.10.5 遍历循环</h4>使用v-for时最好加上key，为了更好的复用<h5>1.10.5.1 遍历数组</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;v-for遍历数组&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--    1.在遍历的过程中，没有使用索引值--&gt;    &lt;ul&gt;        &lt;li v-for&#x3D;&quot;item in names&quot;&gt;&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;    &lt;!--    2.在遍历的过程中，获取索引值--&gt;    &lt;ul&gt;        &lt;li v-for&#x3D;&quot;(item,index) in names&quot;&gt;NaN.&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            names: [&#39;why&#39;, &#39;Mois&#39;, &#39;Tom&#39;, &#39;Jerry&#39;]        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h5>1.10.5.2 遍历对象</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;v-for遍历对象&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;!--    1.在遍历的过程中，如果只是获取一个值，那么获取的是value--&gt;    &lt;ul&gt;        &lt;li v-for&#x3D;&quot;item in info&quot;&gt;&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;    &lt;!--    2.获取key和value （value，key）--&gt;    &lt;ul&gt;        &lt;li v-for&#x3D;&quot;(item,key) in info&quot;&gt;:&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&lt;!--    3.获取key、value和index--&gt;    &lt;ul&gt;        &lt;li v-for&#x3D;&quot;(item,key,index) in info&quot;&gt;:-&lt;&#x2F;li&gt;    &lt;&#x2F;ul&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;    const app &#x3D; new Vue({        el: &#39;#app&#39;,        data: {            info: {                name: &#39;Mois&#39;,                age: 20,                height: 1.88            }        }    })&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><h5>1.10.5.3 v-for中最好加入key，但key不能是index（index会有变化）</h5><img src="/img/v-forKey.png"><h4>1.10.6 响应方法</h4>观察数组编译的方法，使用它们改变数组也会触发视图的更新。<li>push():在数组后面添加元素，可添加多个</li><li>pop()：删除最后一个元素</li><li>shift()：删除第一个元素</li><li>unshift()：在数组最前面添加元素，可添加多个</li><li>splice():删除元素、插入元素、替换元素</li>               删除元素,splice(开始位置,删除几个元素),<br>               删除元素splice(开始位置),删除除开始位置后的元素<br>               替换元素，splice(start，替换几个元素，‘替换的元素’，‘替换的元素’)<br>               插入元素,splice(开始元素,0，‘插入的元素’，‘插入的元素’)<br><li>sort()：排序</li><li>reverse()：反转</li><li>set():添加元素，set(添加位置，添加变量名字，添加变量内容)</li><h3>1.11 书籍购物车的案例</h3><h5>index.html</h5><pre><code>&lt;!DOCTYPE html&gt;&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;&#x2F;title&gt;    &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;style.css&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;div id&#x3D;&quot;app&quot;&gt;    &lt;div v-if&#x3D;&quot;books.length&quot;&gt;        &lt;table&gt;            &lt;thead&gt;            &lt;tr&gt;                &lt;th&gt;&lt;&#x2F;th&gt;                &lt;th&gt;书籍名称&lt;&#x2F;th&gt;                &lt;th&gt;出版日期&lt;&#x2F;th&gt;                &lt;th&gt;价格&lt;&#x2F;th&gt;                &lt;th&gt;购买数量&lt;&#x2F;th&gt;                &lt;th&gt;操作&lt;&#x2F;th&gt;            &lt;&#x2F;tr&gt;            &lt;&#x2F;thead&gt;            &lt;tbody&gt;            &lt;tr v-for&#x3D;&quot;(book,index) in books&quot;&gt;                &lt;td&gt;book.id&lt;&#x2F;td&gt;                &lt;td&gt;book.name&lt;&#x2F;td&gt;                &lt;td&gt;book.data&lt;&#x2F;td&gt;                &lt;td&gt;book.price|showPrice&lt;&#x2F;td&gt;                &lt;td&gt;                    &lt;button @click&#x3D;&quot;decrement(index)&quot; v-bind:disabled&#x3D;&quot;book.count&lt;&#x3D;1&quot;&gt;-&lt;&#x2F;button&gt;                    &lt;button @click&#x3D;&quot;increment(index)&quot;&gt;+&lt;&#x2F;button&gt;                &lt;&#x2F;td&gt;                &lt;td&gt;                    &lt;button @click&#x3D;&quot;removeHandler(index)&quot;&gt;移除&lt;&#x2F;button&gt;                &lt;&#x2F;td&gt;            &lt;&#x2F;tr&gt;            &lt;&#x2F;tbody&gt;        &lt;&#x2F;table&gt;        &lt;h2&gt;总价格：totalPrice|showPrice&lt;&#x2F;h2&gt;    &lt;&#x2F;div&gt;    &lt;div v-else&gt;        &lt;h2&gt;购物车为空&lt;&#x2F;h2&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script src&#x3D;&quot;..&#x2F;js&#x2F;vue.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script src&#x3D;&quot;main.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script&gt;&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre><br><h5>main.js</h5><pre><code>const app &#x3D; new Vue({    el: &#39;#app&#39;,    data: {        books: [            {                id: 1,                name: &#39;《算法导论》&#39;,                data: &#39;2019-03-12&#39;,                price: 89.00,                count: 1            },            {                id: 2,                name: &#39;《UNIX编程艺术》&#39;,                data: &#39;2018-07-13&#39;,                price: 49.00,                count: 5            },            {                id: 3,                name: &#39;《编程珠玑》&#39;,                data: &#39;2020-01-12&#39;,                price: 85.00,                count: 11            },            {                id: 4,                name: &#39;《代码大全》&#39;,                data: &#39;2020-03-22&#39;,                price: 109.00,                count: 2            },        ]    },    methods: {        &#x2F;&#x2F;价格格式化        getFinalPrice(price) {            return &#39;¥&#39; + price.toFixed(2)        },        increment(index) {            this.books[index].count++        },        decrement(index) {            this.books[index].count--        },        removeHandler(index) {            this.books.splice(index, 1)        }    },    &#x2F;&#x2F; 计算属性    computed: {        totalPrice() {            let totalPrice &#x3D; 0            &#x2F;&#x2F;1.普通for循环            for (let i &#x3D; 0; i &lt; this.books.length; i++) {                totalPrice +&#x3D; this.books[i].price * this.books[i].count            }            return totalPrice            &#x2F;&#x2F; 2.for(let i in this.books)            &#x2F;&#x2F;3.for(let i in&#x2F;of this.books)        }    },    &#x2F;&#x2F;过滤器    filters: {        showPrice(price) {            return &#39;¥&#39; + price.toFixed(2)        }    }})</code></pre><br><h5>style.css</h5><pre><code>table {    border: 1px solid #e9e9e9;    border-collapse: collapse;    border-spacing: 0;}th, td {    padding: 8px 16px;    border: 1px solid #e9e9e9;    text-align: left;}th {    background-color: #f7f7f7;    color: #5c6b77;    font-weight: 600;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的博客</title>
      <link href="/2020/05/11/my-new-post/"/>
      <url>/2020/05/11/my-new-post/</url>
      
        <content type="html"><![CDATA[<p>这是我第二篇博客</p>]]></content>
      
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/11/hello-world/"/>
      <url>/2020/05/11/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
